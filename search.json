[{"title":"分布式锁的几种实现方式","url":"/dslock.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n在分布式架构中，由于多线程和多台服务器，何难保证顺序性。如果需要对某一个资源进行限制，比如票务，比如请求幂等性控制等，这个时候分布式锁就排上用处。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 什么是分布式锁\n分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现，如果不同的系统或同一个系统的不同主机之间共享了某个资源时，往往需要互斥来防止彼此干扰来保证一致性。\n\n## 分布式锁需要解决的问题\n1. 互斥性：任意时刻，只能有一个客户端获取锁，不能同时有两个客户端获取到锁。\n2. 安全性：锁只能被持有该锁的客户端删除，不能由其它客户端删除。\n3. 死锁：获取锁的客户端因为某些原因（如down机等）而未能释放锁，其它客户端再也无法获取到该锁。\n4. 容错：当部分节点（redis节点等）down机时，客户端仍然能够获取锁和释放锁。\n\n## 分布式锁的实现方式\n1. 数据库实现\n\n2. 缓存实现，比如redis\n\n3. zookeeper实现\n\n## 未完待续\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["java"],"categories":["分布式架构"]},{"title":"分布式系统理论基础","url":"/dsbasic.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n分布式系统不是万能，不能解决所有痛点。在高可用，一致性，分区容错性必须有所权衡。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## CAP理论\n定理：任何分布式架构都只能同时满足两点，无法三者兼顾。\n* Consistency（一致性），数据一致更新，所有的数据变动都是同步的。\n* Availability（可用性），好的响应性能。\n* Partition tolerance（分区容忍性）可靠性，机器宕机是否影响使用。\n\n关系数据库的ACID模型拥有 高一致性 + 可用性 很难进行分区：\n1. Atomicity原子性：一个事务中所有操作都必须全部完成，要么全部不完成。\n2. Consistency一致性. 在事务开始或结束时，数据库应该在一致状态。\n3. Isolation隔离性. 事务将假定只有它自己在操作数据库，彼此不知晓。\n4. Durability持久性 一旦事务完成，就不能返回。\n跨数据库两段提交事务：2PC (two-phase commit)， 2PC is the anti-scalability pattern (Pat Helland)\n是反可伸缩模式的，JavaEE中的JTA事务可以支持2PC。因为2PC是反模式，尽量不要使用2PC，使用BASE来回避。\n\n## BASE理论\n* Basically Available 基本可用，支持分区失败\n* Soft state 软状态，允许状态某个时间短不同步，或者异步\n* Eventually consistent 最终一致性，要求数据最终结果一致，而不是时刻高度一致。\n\n## paxos协议\nPaxos算法的目的是为了解决分布式环境下一致性的问题。多个节点并发操纵数据，如何保证在读写过程中数据的一致性，并且解决方案要能适应分布式环境下的不可靠性（系统如何就一个值达到统一）。\n### Paxos的两个组件:\n* Proposer：提议发起者，处理客户端请求，将客户端的请求发送到集群中，以便决定这个值是否可以被批准。\n* Acceptor:提议批准者，负责处理接收到的提议，他们的回复就是一次投票。会存储一些状态来决定是否接收一个值\n\n### Paxos有两个原则\n1. 安全原则---保证不能做错的事\n    * a） 针对某个实例的表决只能有一个值被批准，不能出现一个被批准的值被另一个值覆盖的情况；(假设有一个值被多数Acceptor批准了，那么这个值就只能被学习)\n    * b） 每个节点只能学习到已经被批准的值，不能学习没有被批准的值。\n2. 存活原则---只要有多数服务器存活并且彼此间可以通信，最终都要做到的下列事情：\n    * a）最终会批准某个被提议的值；\n    * b）一个值被批准了，其他服务器最终会学习到这个值。\n\n## zab协议(ZooKeeper Atomic broadcast protocol)\nZAB协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。\n\n### Phase 0: Leader election（选举阶段）\n节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。只有到达 Phase 3 准 leader 才会成为真正的 leader。这一阶段的目的是就是为了选出一个准 leader，然后进入下一个阶段。\n\n### Phase 1: Discovery（发现阶段）\n在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。这个一阶段的主要目的是发现当前大多数节点接收的最新提议，并且准 leader 生成新的 epoch，让 followers 接受，更新它们的 acceptedEpoch。\n一个 follower 只会连接一个 leader，如果有一个节点 f 认为另一个 follower p 是 leader，f 在尝试连接 p 时会被拒绝，f 被拒绝之后，就会进入 Phase 0。\n\n### Phase 2: Synchronization（同步阶段）\n同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。只有当 quorum 都同步完成，准 leader 才会成为真正的 leader。follower 只会接收 zxid 比自己的 lastZxid 大的提议。\n\n### Phase 3: Broadcast（广播阶段）\n到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。\n\n## raft协议\n在Raft中，每个结点会处于下面三种状态中的一种：\n### follower\n所有结点都以follower的状态开始。如果没收到leader消息则会变成candidate状态。\n### candidate\n会向其他结点“拉选票”，如果得到大部分的票则成为leader。这个过程就叫做Leader选举(Leader Election)\n### leader\n所有对系统的修改都会先经过leader。每个修改都会写一条日志(log entry)。leader收到修改请求后的过程如下，这个过程叫做日志复制(Log Replication)：\n\n    1. 复制日志到所有follower结点(replicate entry)\n    2. 大部分结点响应时才提交日志\n    3. 通知所有follower结点日志已提交\n    4. 所有follower也提交日志\n    5. 现在整个系统处于一致的状态\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["protocol"],"categories":["分布式架构"]},{"title":"为什么使用Zookeeper？","url":"/zookeeper.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n随着大型互联网的发展，分布式系统应用越来越来越广泛，zookeeper成了分布式系统的标配。集群容错，动态负载均衡，动态扩容，异地多活等架构都依赖于zookeeper而搭建。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## zookeeper是什么？\nzookeeper是由雅虎创建的，基于google chubby,一个开源的分布式协调服务，是分布式数据一致性的解决方案。\n\n## zookeeper的特性\n* 顺序一致性，从同一个客户端发起的事务请求，最终会严格按照顺序被应用到zookeeper中。\n* 原子性，事务请求在所有集群是一致的，要么都成功，要么都失败。\n* 可靠性，一旦服务器成功应用某个事务，那么所有集群中一定同步并保留。\n* 实时性，一个事务被应用，客户端能立即从服务端读取到状态变化。\n\n## zookeeper的原理？\n基于分布式协议pasxo，而实现了自己的zab协议。保证数据的一致性。\n\n## zookeeper的数据模型\n* 持久化节点，节点创建后一直存在，直到主动删除。\n* 持久化有序节点，每个节点都会为它的一级子节点维护一个顺序。\n* 临时节点，临时节点的生命周期和客户端会话保持一直。客户端会话失效，节点自动清理。\n* 临时有序节点，临时节点基础上多一个顺序性特性。\n\n## zookeeper使用场景有哪些？\n* 订阅发布\n    * watcher机制\n    * 统一配置管理(disconf)\n* 分布式锁（redis也可以）\n* 分布式队列\n* 负载均衡(dubbo)\n* ID生成器\n* master选举(kafka,hadoop,hbase)\n\n## 集群角色有哪些？\n### leader\n1. 事务请求的唯一调度者和处理者，保证集群事务的处理顺序\n2. 集群内部服务的调度者\n\n### follower\n1. 处理非事务请求，以及转发事务请求到leader\n2. 参与事务请求提议的投票\n3. 参与leader选举的投票\n\n### observer\n1. 观察集群中最新状态的变化并同步到observer服务器上\n2. 增加observer不影响集群事务处理能力，还能提升非事务请求的处理能力\n\n## zookeeper集群为什么是奇数？\nzookeeper事务请求提议需要超过半数的机器，假如是2(n+1)台,需要n+2台机器同意，\n由于在增删改操作中需要半数以上服务器通过，来分析以下情况。\n2台服务器，至少2台正常运行才行（2的半数为1，半数以上最少为2），正常运行1台服务器都不允许挂掉\n3台服务器，至少2台正常运行才行（3的半数为1.5，半数以上最少为2），正常运行可以允许1台服务器挂掉\n4台服务器，至少3台正常运行才行（4的半数为2，半数以上最少为3），正常运行可以允许1台服务器挂掉\n5台服务器，至少3台正常运行才行（5的半数为2.5，半数以上最少为3），正常运行可以允许2台服务器挂掉\n6台服务器，至少3台正常运行才行（6的半数为3，半数以上最少为4），正常运行可以允许2台服务器挂掉\n\n## zookeeper日志管理？\n\n## leader选举的原理\n\n\n## 未完待续\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["zookeeper"],"categories":["分布式架构"]},{"title":"查找链表倒数第N个元素","url":"/descNode.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n链表应用很广泛，有单向链表，双向链表。单向链表如何查找倒数第n个元素呢？本文以java代码实现链表反向查找。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 单向链表的定义\n单向链表，主要有数据存储，下一个节点的引用这两个元素组成。\n```\npublic class Node {\n    int value;\n    Node next;\n\n    Node(int value) {\n        this.value = value;\n    }\n}\n```\n\n## 遍历倒数第n个元素\n在查找过程中，设置两个指针，让其中一个指针比另一个指针先前移k-1步，\n然后两个指针同时往前移动。循环直到先行的指针指为NULL时，另一个指针所指的位置就是所要找的位置\n算法复杂度为o（n）\n\n```\npublic Node findDescEle(Node head, int k) {\n    if (k < 1 || head == null) {\n        return null;\n    }\n    Node p1 = head;\n    Node p2 = head;\n    //前移k-1步\n    int step = 0;\n    for (int i = 0; i < k; i++) {\n        step++;\n        if (p1.next != null) {\n            p1 = p1.next;\n        } else {\n            return null;\n        }\n    }\n    while (p1 != null) {\n        step++;\n        p1 = p1.next;\n        p2 = p2.next;\n    }\n    System.out.println(\"o(n)==\" + step);\n    return p2;\n}\n```\n## 总结\n查找链表倒数第n个元素，复杂度为o(n),使用两个指针即可简单实现。\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["算法"],"categories":["algorithm"]},{"title":"Sprigmvc项目转为springboot","url":"/sprigmvc2boot.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n是否有老掉牙的springmvc项目，想转成springboot项目，看这个文章就对了。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 说明\n* 如果你的项目连maven项目都不是，请自行转为maven项目，在按照本教程进行。\n* 本教程适用于spring+springmvc+mybatis+shiro的maven项目。\n\n## 1.修改pom文件依赖\n1. 删除之前的spring依赖，添加springboot依赖\n```xml\n<parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>1.5.9.RELEASE</version>\n</parent>\n<dependencies>\n       <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n\n            <!-- 这个是剔除掉自带的 tomcat部署的-->\n            <exclusions>\n                <exclusion>\n                    <groupId>org.springframework.boot</groupId>\n                    <artifactId>spring-boot-starter-tomcat</artifactId>\n                </exclusion>\n            </exclusions>\n\n        </dependency>\n        <!-- tomcat容器部署 -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-tomcat</artifactId>\n            <!--<scope>compile</scope>-->\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis.spring.boot</groupId>\n            <artifactId>mybatis-spring-boot-starter</artifactId>\n            <version>1.3.0</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-devtools</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <!-- 支持 @ConfigurationProperties 注解 -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-configuration-processor</artifactId>\n            <optional>true</optional>\n        </dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.apache.tomcat.embed</groupId>\n\t\t\t<artifactId>tomcat-embed-jasper</artifactId>\n\t\t</dependency>\n</dependencies>\n```\n2. 添加springboot构建插件\n```xml\n<plugins>\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <configuration>\n            <source>1.7</source>\n            <target>1.7</target>\n        </configuration>\n    </plugin>\n    <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n        <version>1.5.9.RELEASE</version>\n        <executions>\n            <execution>\n                <goals>\n                    <goal>repackage</goal>\n                </goals>\n            </execution>\n        </executions>\n    </plugin>\n</plugins>\n```\n## 2.添加application启动文件\n注意，如果Application在controller，service，dao的上一层包里，无需配置`@ComponentScan`,\n否则，需要指明要扫描的包。\n```java\n@SpringBootApplication\n//@ComponentScan({\"com.cms.controller\",\"com.cms.service\",\"com.cms.dao\"})\npublic class Application extends SpringBootServletInitializer {\n\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\n        return application.sources(Application.class);\n    }\n\n    public static void main(String[] args) throws Exception {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n## 3.添加springboot配置文件\n1. 在resources下面添加application.properties文件\n2. 添加基本配置\n```\n#默认前缀\nserver.contextPath=/\n# 指定环境\nspring.profiles.active=local\n# jsp配置\nspring.mvc.view.prefix=/WEB-INF/jsp/\nspring.mvc.view.suffix=.jsp\n#log配置文件\nlogging.config=classpath:logback-cms.xml\n#log路径\nlogging.path=/Users/mac/work-tommy/cms-springboot/logs/\n#数据源\nspring.datasource.name=adminDataSource\nspring.datasource.driverClassName = com.mysql.jdbc.Driver\nspring.datasource.url = jdbc:mysql://localhost:3306/mycms?useUnicode=true&autoReconnect=true&characterEncoding=utf-8\nspring.datasource.username = root\nspring.datasource.password = 123456\n```\n## 4.使用@Configuration注入配置\n1. 注入mybatis配置,分页插件请自主选择\n```java\n@Configuration\n@MapperScan(basePackages = \"com.kuwo.dao\",sqlSessionTemplateRef  = \"adminSqlSessionTemplate\")\npublic class AdminDataSourceConfig {\n\n    @Bean(name = \"adminDataSource\")\n    @ConfigurationProperties(prefix = \"spring.datasource\")\n    @Primary\n    public DataSource adminDataSource() {\n        return DataSourceBuilder.create().build();\n    }\n\n    @Bean(name = \"adminSqlSessionFactory\")\n    @Primary\n    public SqlSessionFactory adminSqlSessionFactory(@Qualifier(\"adminDataSource\") DataSource dataSource) throws Exception {\n        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();\n        bean.setDataSource(dataSource);\n        //分页插件\n//        PageHelper pageHelper = new PageHelper();\n        PagePlugin pagePlugin = new PagePlugin();\n//        Properties props = new Properties();\n//        props.setProperty(\"reasonable\", \"true\");\n//        props.setProperty(\"supportMethodsArguments\", \"true\");\n//        props.setProperty(\"returnPageInfo\", \"check\");\n//        props.setProperty(\"params\", \"count=countSql\");\n//        pageHelper.setProperties(props);\n        //添加插件\n        bean.setPlugins(new Interceptor[]{pagePlugin});\n        // 添加mybatis配置文件\n        bean.setConfigLocation(new DefaultResourceLoader().getResource(\"classpath:mybatis/mybatis-config.xml\"));\n        // 添加mybatis映射文件\n        bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath:mybatis/system/*.xml\"));\n        return bean.getObject();\n    }\n\n    @Bean(name = \"adminTransactionManager\")\n    @Primary\n    public DataSourceTransactionManager adminTransactionManager(@Qualifier(\"adminDataSource\") DataSource dataSource) {\n        return new DataSourceTransactionManager(dataSource);\n    }\n\n    @Bean(name = \"adminSqlSessionTemplate\")\n    @Primary\n    public SqlSessionTemplate adminSqlSessionTemplate(@Qualifier(\"adminSqlSessionFactory\") SqlSessionFactory sqlSessionFactory) throws Exception {\n        return new SqlSessionTemplate(sqlSessionFactory);\n    }\n}\n```\n\n2. 添加Interceptor配置,注意addInterceptor的顺序，不要搞乱了\n```java\n@Configuration\npublic class InterceptorConfiguration extends WebMvcConfigurerAdapter{\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new LoginHandlerInterceptor());\n    }\n}\n```\n3. 添加shiro配置文件\n    * 注意：本来使用redis做session缓存，但是和shiro集成发现一个问题，user对象存储以后，从shiro中获取后，无法进行类型转换，所以暂时放弃了redis做session缓存。\n\n```java\n@Configuration\npublic class ShiroConfiguration {\n    @Value(\"${spring.redis.host}\")\n    private String host;\n\n    @Value(\"${spring.redis.port}\")\n    private int port;\n\n    @Value(\"${spring.redis.timeout}\")\n    private int timeout;\n    @Bean\n    public static LifecycleBeanPostProcessor getLifecycleBeanPostProcessor() {\n        return new LifecycleBeanPostProcessor();\n    }\n\n    /**\n     * ShiroFilterFactoryBean 处理拦截资源文件问题。\n     * 注意：单独一个ShiroFilterFactoryBean配置是或报错的，因为在\n     * 初始化ShiroFilterFactoryBean的时候需要注入：SecurityManager\n     *\n     Filter Chain定义说明\n     1、一个URL可以配置多个Filter，使用逗号分隔\n     2、当设置多个过滤器时，全部验证通过，才视为通过\n     3、部分过滤器可指定参数，如perms，roles\n     *\n     */\n    @Bean\n    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager){\n        System.out.println(\"ShiroConfiguration.shirFilter()\");\n        ShiroFilterFactoryBean shiroFilterFactoryBean  = new ShiroFilterFactoryBean();\n\n        // 必须设置 SecurityManager\n        shiroFilterFactoryBean.setSecurityManager(securityManager);\n        // 如果不设置默认会自动寻找Web工程根目录下的\"/login.jsp\"页面\n        shiroFilterFactoryBean.setLoginUrl(\"/login_toLogin\");\n        // 登录成功后要跳转的链接\n        shiroFilterFactoryBean.setSuccessUrl(\"/usersPage\");\n        //未授权界面;\n        shiroFilterFactoryBean.setUnauthorizedUrl(\"/403\");\n        //拦截器.\n        Map<String,String> filterChainDefinitionMap = new LinkedHashMap<>();\n\n        //配置退出 过滤器,其中的具体的退出代码Shiro已经替我们实现了\n        filterChainDefinitionMap.put(\"/logout\", \"logout\");\n        filterChainDefinitionMap.put(\"/login_toLogin\", \"anon\");\n        filterChainDefinitionMap.put(\"/login_login\", \"anon\");\n        filterChainDefinitionMap.put(\"/static/login/**\",\"anon\");\n        filterChainDefinitionMap.put(\"/static/js/**\",\"anon\");\n        filterChainDefinitionMap.put(\"/uploadFiles/uploadImgs/**\",\"anon\");\n        filterChainDefinitionMap.put(\"/code.do\",\"anon\");\n        filterChainDefinitionMap.put(\"/font-awesome/**\",\"anon\");\n        //<!-- 过滤链定义，从上向下顺序执行，一般将 /**放在最为下边 -->:这是一个坑呢，一不小心代码就不好使了;\n        //<!-- authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问-->\n\n        filterChainDefinitionMap.put(\"/**\", \"authc\");\n\n\n        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);\n        return shiroFilterFactoryBean;\n    }\n\n\n    @Bean\n    public SecurityManager securityManager(){\n        DefaultWebSecurityManager securityManager =  new DefaultWebSecurityManager();\n        //设置realm.\n        securityManager.setRealm(myShiroRealm());\n        // 自定义缓存实现 使用redis\n        //securityManager.setCacheManager(cacheManager());\n        // 自定义session管理 使用redis\n        securityManager.setSessionManager(sessionManager());\n        return securityManager;\n    }\n\n    @Bean\n    public ShiroRealm myShiroRealm(){\n        ShiroRealm myShiroRealm = new ShiroRealm();\n//        myShiroRealm.setCredentialsMatcher(hashedCredentialsMatcher());\n        return myShiroRealm;\n    }\n\n}\n    /**\n     *  开启shiro aop注解支持.\n     *  使用代理方式;所以需要开启代码支持;\n     * @param securityManager\n     * @return\n     */\n    @Bean\n    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager){\n        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor();\n        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);\n        return authorizationAttributeSourceAdvisor;\n    }\n\n    /**\n     * 配置shiro redisManager\n     * 使用的是shiro-redis开源插件\n     * @return\n     */\n    public RedisManager redisManager() {\n        RedisManager redisManager = new RedisManager();\n        redisManager.setHost(host);\n        redisManager.setPort(port);\n        redisManager.setExpire(1800);\n        redisManager.setTimeout(timeout);\n        // redisManager.setPassword(password);\n        return redisManager;\n    }\n\n    /**\n     * cacheManager 缓存 redis实现\n     * 使用的是shiro-redis开源插件\n     * @return\n     */\n    public RedisCacheManager cacheManager() {\n        RedisCacheManager redisCacheManager = new RedisCacheManager();\n        redisCacheManager.setRedisManager(redisManager());\n        return redisCacheManager;\n    }\n\n    /**\n     * RedisSessionDAO shiro sessionDao层的实现 通过redis\n     * 使用的是shiro-redis开源插件\n     */\n    @Bean\n    public RedisSessionDAO redisSessionDAO() {\n        RedisSessionDAO redisSessionDAO = new RedisSessionDAO();\n        redisSessionDAO.setRedisManager(redisManager());\n        return redisSessionDAO;\n    }\n\n    @Bean\n    public DefaultWebSessionManager sessionManager() {\n        DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();\n//        sessionManager.setSessionDAO(redisSessionDAO());\n        return sessionManager;\n    }\n\n}\n```\n\n## 总结\n搞了一天时间把项目转成springboot，查阅各种资料，希望这篇文章能够为你带来帮助。\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["java"],"categories":["项目实战"]},{"title":"Mybatis-Generator","url":"/mybatis-generator.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nmybatis反向生成器，根据数据库表，自动创建pojo，mapper以及mybatis配置文件，能极大的提高开发效率。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 插件介绍\n本插件fork自[mybatis-generator-gui](http://link),在此基础上加了批量生成表。\n\n## 插件特性\n1. 保存数据库配置\n2. 根据表生成pojo，mapper以及mybatis配置文件\n3. 批量生成\n4. 其它功能（待开发）\n\n## 插件使用\n### 要求\n本工具由于使用了Java 8的众多特性，所以要求JDK <strong>1.8.0.60</strong>以上版本，对于JDK版本还没有升级的童鞋表示歉意。\n\n### 启动本软件\n\n* 方法一: 自助构建\n\n```bash\n    git clone https://github.com/maochunguang/mybatis-generator-gui\n    cd mybatis-generator-gui\n    mvn jfx:jar\n    cd target/jfx/app/\n    java -jar mybatis-generator-gui.jar\n```\n* 方法二: IDE中运行Eclipse or IntelliJ IDEA中启动, 找到`com.zzg.mybatis.generator.MainUI`类并运行就可以了\n\n\n### 文档\n更多详细文档请参考本库的Wiki\n* [Usage](https://github.com/maochunguang/mybatis-generator-gui/wiki)\n\n## 截图参考\n![MainUI](http://o7kalf5h3.bkt.clouddn.com/mybatis.png)\n\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["mysql"],"categories":["开发工具"]},{"title":"突破算法第11天-红黑树","url":"/suanfa-11.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n红黑树\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 红黑树\n本文的主要内容：\n1. 红黑树的基本概念以及最重要的 5 点规则。\n2. 红黑树的左旋转、右旋转、重新着色的原理与 Java 实现；\n3. 红黑树的增加结点、删除结点过程解析；\n\n## 红黑树的基本概念与数据结构表示\n\n首先红黑树来个定义：\n\n> 红黑树定义：红黑树又称红 - 黑二叉树，它首先是一颗二叉树，它具体二叉树所有的特性。同时红黑树更是一颗自平衡的排序二叉树 (平衡二叉树的一种实现方式)。\n\n我们知道一颗基本的二叉排序树他们都需要满足一个基本性质：即树中的任何节点的值大于它的左子节点，且小于它的右子节点。\n\n按照这个基本性质使得树的检索效率大大提高。我们知道在生成二叉排序树的过程是非常容易失衡的，最坏的情况就是一边倒（只有右 / 左子树），这样势必会导致二叉树的检索效率大大降低（O(n)），所以为了维持二叉排序树的平衡，大牛们提出了各种平衡二叉树的实现算法，如：AVL，SBT，伸展树，TREAP ，红黑树等等。\n\n> 平衡二叉树必须具备如下特性：它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个子节点，其左右子树的高度都相近。下面给出平衡二叉树的几个示意图：\n\n![红黑树](http://img.blog.csdn.net/20170110134212154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDg1MzI2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n红黑树顾名思义就是结点是红色或者是黑色的平衡二叉树，它通过颜色的约束来维持着二叉树的平衡。对于一棵有效的红黑树而言我们必须增加如下规则，这也是红黑树最重要的 5 点规则：\n\n1. 每个结点都只能是红色或者黑色中的一种。\n2. 根结点是黑色的。\n3. 每个叶结点（NIL 节点，空节点）是黑色的。\n4. 如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。\n5. 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。\n\n这些约束强制了红黑树的关键性质: 从根到叶子最长的可能路径不多于最短的可能路径的两倍长。结果是这棵树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。所以红黑树它是复杂而高效的，其检索效率 O(lg n)。下图为一颗典型的红黑二叉树：\n![](http://img.blog.csdn.net/20170110134903553?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDg1MzI2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n上面关于红黑树的概念基本已经说得很清楚了，下面给出红黑树的结点用 Java 表示数据结构：\n\n```java\nprivate static final boolean RED = true;\nprivate static final boolean BLACK = false;\nprivate Node root;//二叉查找树的根节点\n\n//结点数据结构\nprivate class Node{\n    private Key key;//键\n    private Value value;//值\n    private Node left, right;//指向子树的链接:左子树和右子树.\n    private int N;//以该节点为根的子树中的结点总数\n    boolean color;//由其父结点指向它的链接的颜色也就是结点颜色.\n\n    public Node(Key key, Value value, int N, boolean color) {\n        this.key = key;\n        this.value = value;\n        this.N = N;\n        this.color = color;\n    }\n}\n\n/**\n * 获取整个二叉查找树的大小\n * @return\n */\npublic int size(){\n    return size(root);\n}\n/**\n * 获取某一个结点为根结点的二叉查找树的大小\n * @param x\n * @return\n */\nprivate int size(Node x){\n    if(x == null){\n        return 0;\n    } else {\n        return x.N;\n    }\n}\nprivate boolean isRed(Node x){\n    if(x == null){\n        return false;\n    }\n    return x.color == RED;\n}\n```\n\n## 红黑树的三个基本操作\n\n红黑树在插入，删除过程中可能会破坏原本的平衡条件导致不满足红黑树的性质，这时候一般情况下要通过左旋、右旋和重新着色这个三个操作来使红黑树重新满足平衡化条件。\n\n## 旋转\n\n旋转分为左旋和右旋。在我们实现某些操作中可能会出现红色右链接或则两个连续的红链接，这时候就要通过旋转修复。\n\n通常左旋操作用于将一个向右倾斜的红色链接 (这个红色链接链连接的两个结点均是红色结点) 旋转为向左链接。对比操作前后，可以看出，该操作实际上是将红线链接的两个结点中的一个较大的结点移动到根结点上。\n\n左旋的示意图如下：\n![](http://img.blog.csdn.net/20170110141248765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDg1MzI2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![](http://img.blog.csdn.net/20170110141309245?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDg1MzI2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n左旋的 Java 实现如下：\n\n```java\n/**\n * 左旋转\n * @param h\n * @return\n */\nprivate Node rotateLeft(Node h){\n    Node x = h.right;\n    //把x的左结点赋值给h的右结点\n    h.right = x.left;\n    //把h赋值给x的左结点\n    x.left = h;\n    //\n    x.color = h.color;\n    h.color = RED;\n    x.N = h.N;\n    h.N = 1+ size(h.left) + size(h.right);\n\n    return x;\n}\n```\n\n左旋的动画效果如下：\n![](http://img.blog.csdn.net/20170110142027660?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDg1MzI2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n右旋其实就是左旋的逆操作：\n![](http://img.blog.csdn.net/20170110142230957?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDg1MzI2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n![](http://img.blog.csdn.net/20170110142252648?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDg1MzI2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n右旋的代码如下：\n\n```java\n/**\n * 右旋转\n * @param h\n * @return\n */\nprivate Node rotateRight(Node h){\n    Node x = h.left;\n    h.left = x.right;\n    x.right = h;\n\n    x.color = h.color;\n    h.color = RED;\n    x.N = h.N;\n    h.N = 1+ size(h.left) + size(h.right);\n    return x;\n}\n```\n\n右旋的动态示意图：\n![](http://img.blog.csdn.net/20170110142410322?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDg1MzI2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## <a></a>颜色反转\n\n当出现一个临时的 4-node 的时候，即一个节点的两个子节点均为红色，如下图：\n![](http://img.blog.csdn.net/20170110143015321?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDg1MzI2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n我们需要将 E 提升至父节点，操作方法很简单，就是把 E 对子节点的连线设置为黑色，自己的颜色设置为红色。颜色反转之后颜色如下：\n![](http://img.blog.csdn.net/20170110143225712?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDg1MzI2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n实现代码如下：\n\n```java\n/**\n * 颜色转换\n * @param h\n */\nprivate void flipColors(Node h){\n    h.color = RED;//父结点颜色变红\n    h.left.color = BLACK;//子结点颜色变黑\n    h.right.color = BLACK;//子结点颜色变黑\n}\n```\n\n> 注意：以上的旋转和颜色反转操作都是针对单一结点的，反转或则颜色反转操作之后可能引起其父结点又不满足平衡性质。\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["算法"],"categories":["algorithm"]},{"title":"突破算法第10天-二叉树","url":"/suanfa-10.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n用java实现算法求出二叉树的高度\n<!-- more -->\n<The rest of contents | 余下全文>\n## 树\n* 先序遍历：先访问根结点，然后左节点，最后右节点\n* 中序遍历：先访问左结点，然后根节点，最后右节点\n* 后续遍历：先访问左结点，然后右节点，最后根节点\n\n## java实现\n```java\npublic class TreeNode {\n    TreeNode left;\n    TreeNode right;\n    int val;\n\n    TreeNode(int val) {\n        this.val = val;\n    }\n\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(1);\n        TreeNode left1 = new TreeNode(2);\n        TreeNode left2 = new TreeNode(3);\n        TreeNode right1 = new TreeNode(4);\n        //创建一棵树\n        root.left = left1;\n        left1.right = left2;\n        root.right = right1;\n        scanNodes(root);\n        System.out.println(\"树的深度是：\" + getDepth(root));\n        System.out.println(\"非递归深度：\" + findDeep2(root));\n    }\n\n    // 递归返回二叉树的深度\n    static int getDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int left = getDepth(root.left);\n        int right = getDepth(root.right);\n        return left > right ? left + 1 : right + 1;\n    }\n\n    static void scanNodes(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n//        System.out.println(root.val); //先序遍历\n        scanNodes(root.left);\n//        System.out.println(root.val); //中序遍历\n        scanNodes(root.right);\n        System.out.println(root.val); // 后序遍历\n    }\n    // 非递归求深度\n    public static int findDeep2(TreeNode root) {\n        if (root == null)\n            return 0;\n        TreeNode current = null;\n        LinkedList<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int cur, next;\n        int level = 0;\n        while (!queue.isEmpty()) {\n            cur = 0;\n            //当遍历完当前层以后，队列里元素全是下一层的元素，队列的长度是这一层的节点的个数\n            next = queue.size();\n            while (cur < next) {\n                current = queue.poll();\n                cur++;\n                //把当前节点的左右节点入队（如果存在的话）  \n                if (current.left != null) {\n                    queue.offer(current.left);\n                }\n                if (current.right != null) {\n                    queue.offer(current.right);\n                }\n            }\n            level++;\n        }\n        return level;\n    }\n}\n\n```\n\n## 树的变种\n二叉查找树，平衡二叉查找树，红黑树，b树\n红黑树和平衡二叉树（AVL树）类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。红黑树和AVL树的区别在于它使用颜色来标识结点的高度，它所追求的是局部平衡而不是AVL树中的非常严格的平衡。\n由于二叉树的效率和深度息息相关，于是出现了多路的B树，B+树等等。b树是叶子为n的平衡树。\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["算法"],"categories":["algorithm"]},{"title":"突破算法第九天-排序算法比较","url":"/suanfa-9.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n排序算法个有千秋，有的性能高，有的性能很低。这就要求我们对常用的排序算法要全面了解，不要用错了算法，导致性能问题。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 排序算法性能比较·\n借一张网路上的比较图。特别直观。\n![算法比较](http://o7kalf5h3.bkt.clouddn.com/sortcom.jpg)\n\n## \b\b排序算法总结\n个人看法：\n* 一般的情况还是以快速排序为主，\n* 对于多个有序的数组合并的情况使用归并排序\n* 性能要求快，空间足够，待排序的元素都要在一定的范围内使用桶排序\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["算法"],"categories":["algorithm"]},{"title":"突破算法第八天-桶排序","url":"/suanfa-8.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n桶排序是个神奇的排序，在某些情况下可以达到O(N)的复杂度，快的离谱。但是桶排序是利用空间换时间，在空间充足的情况下，可以用桶排序进行高效的排序。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 桶排序的基本原理\n将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(nlogn) 下限的影响， 简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序\n\n## 桶排序的java实现\n```java\npublic static void bucketSort1(int[] arr){\n        //分桶，这里采用映射函数f(x)=x/10。\n        int bucketCount =10;\n        Integer[][] bucket = new Integer[bucketCount][arr.length];\n        for (int i=0; i<arr.length; i++){\n            int quotient = arr[i]/10;\n            for (int j=0; j<arr.length; j++){\n                if (bucket[quotient][j]==null){\n                    bucket[quotient][j]=arr[i];\n                    break;\n                }\n            }\n        }\n        //小桶排序\n        for (int i=0; i<bucket.length; i++){\n            //insertion sort\n            for (int j=1; j<bucket[i].length; ++j){\n                if(bucket[i][j]==null){\n                    break;\n                }\n                int value = bucket[i][j];\n                int position=j;\n                while (position>0 && bucket[i][position-1]>value){\n                    bucket[i][position] = bucket[i][position-1];\n                    position--;\n                }\n                bucket[i][position] = value;\n            }\n\n        }\n        //输出\n        for (int i=0, index=0; i<bucket.length; i++){\n            for (int j=0; j<bucket[i].length; j++){\n                if (bucket[i][j]!=null){\n                    arr[index] = bucket[i][j];\n                    index++;\n                }\n                else{\n                    break;\n                }\n            }\n        }\n    }\n```\n## 算法复杂度\n前面说的几大排序算法 ，大部分时间复杂度都是O（n2），也有部分排序算法时间复杂度是O(nlogn)。而桶式排序却能实现O（n）的时间复杂度。\n但桶排序的缺点是：\n1. 首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。\n2. 其次待排序的元素都要在一定的范围内，限制较多。\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["算法"],"categories":["algorithm"]},{"title":"突破算法第七天-堆排序","url":"/suanfa-7.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n堆排序是利用二叉树的原理实现的一种排序，难点在于要构建堆,构建堆一般可以采用下沉或者上浮的算法进行。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 堆排序的基本原理\n初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。\n因此，实现堆排序需解决两个问题：\n1. 如何将n 个待排序的数建成堆；\n2. 输出堆顶元素后，怎样调整剩余n-1 个元素，使其成为一个新堆。\n\n## 堆排序java实现\n```java\npublic static void sort(int[] a) {\n        int n = a.length;\n        for (int k = n / 2; k >= 1; k--)\n            sink(a, k, n);\n        while (n > 1) {\n            swap(a, 1, n--);\n            sink(a, 1, n);\n        }\n    }\n\nprivate static void sink(int[] a, int k, int n) {\n    while (2 * k <= n) {\n        int j = 2 * k;\n        if (j < n && a[j - 1] < a[j + 1 - 1]) j++;\n        if (a[k - 1] >= a[j - 1]) break;\n        swap(a, k, j);\n        k = j;\n    }\n}\n\nprivate static void swap(int[] a, int i, int j) {\n    int swap = a[i - 1];\n    a[i - 1] = a[j - 1];\n    a[j - 1] = swap;\n}\n\npublic static void main(String[] args) {\n    int[] arr = {49, 38, 65, 97, 76, 13, 27, 4, 78, 34, 12, 64, 1, 8};\n    sort(arr);\n    System.out.println(\"排序之后：\");\n    System.out.println(Arrays.toString(arr));\n}\n```\n## 算法复杂度\n堆排序的平均时间复杂度为Ο(nlogn)\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["算法"],"categories":["algorithm"]},{"title":"突破算法第六天-冒泡排序","url":"/suanfa-6.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n冒泡排序也非常简单，效率比较低。了解即可。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 冒泡排序的原理\n在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。\n\n![冒泡排序图](http://o7kalf5h3.bkt.clouddn.com/bubbleSort.jpg)\n\n## 冒泡排序的java实现\n```java\nprivate static void bubbleSort(int a[], int n) {\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = 0; j < n - i - 1; ++j) {\n            if (a[j] > a[j + 1]) {\n                int tmp = a[j];\n                a[j] = a[j + 1];\n                a[j + 1] = tmp;\n            }\n        }\n    }\n}\n```\n## 算法复杂度\n冒泡排序的复杂度为O(n^2)\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["算法"],"categories":["algorithm"]},{"title":"突破算法第五天-选择排序","url":"/suanfa-5.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n选择排序很简单，属于交换排序算法。通过比较找到最大值或最小值，然后进行交换。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 选择排序的原理\n首先找到数组中最小的元素，与数组第一个元素交换，然后在剩下的元素中选择最小的，与第二个元素交换，以此类推，直到排序完成。  \n![选择排序图](http://o7kalf5h3.bkt.clouddn.com/selectSort.jpg)\n\n## 选择排序的java实现\n```java\n    private static void sort(int[] a) {\n        int len = a.length;\n        for (int i = 1; i < len; i++) {\n            for (int j = i; j > 0 && (a[j] < a[j - 1]); j--) {\n                swap(a, j, j - 1);\n            }\n        }\n    }\n\n    private static void swap(int[] a, int i, int j) {\n        int swap = a[i];\n        a[i] = a[j];\n        a[j] = swap;\n    }\n```\n## 算法复杂度\n选择排序的算法复杂度是O(n^2)\n\n## 改进\n1. 每次选择的时候把最大值和最小值都比较出来，双向进行交换排序\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["算法"],"categories":["algorithm"]},{"title":"突破算法第一天-归并排序","url":"/suanfa-4.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n归并排序是利用分治思想进行排序的典型应用，特别是对几个基本有序的子序列合并时，效率最高。在实际应用中，分布式应用，分布式查询排序会比较多应用到归并排序。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 归并排序的原理\n归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。\n归并排序分为两种种，第一种是自底向上的归并。\n\n第二种是自顶向下的归并。\n\n## 自底向上的归并排序java实现\n```java\npublic class MergeSortBU {\n    private static void merge(int[] a, int[] aux, int lo, int mid, int hi) {\n        // 复制到aux[]\n        for (int k = lo; k <= hi; k++) {\n            aux[k] = a[k];\n        }\n        // 合并回 a[]\n        int i = lo, j = mid + 1;\n        for (int k = lo; k <= hi; k++) {\n            if (i > mid) a[k] = aux[j++];\n            else if (j > hi) a[k] = aux[i++];\n            else if (aux[j] < aux[i]) a[k] = aux[j++];\n            else a[k] = aux[i++];\n        }\n    }\n\n    public static void mergeSort(int[] a) {\n        int n = a.length;\n        int[] aux = new int[n];\n        for (int len = 1; len < n; len *= 2) {\n            for (int lo = 0; lo < n - len; lo += len + len) {\n                int mid = lo + len - 1;\n                int hi = Math.min(lo + len + len - 1, n - 1);\n                merge(a, aux, lo, mid, hi);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {49, 38, 65, 97, 76, 13, 27, 4, 78, 34, 12, 64, 1, 8};\n        mergeSort(arr);\n        System.out.println(\"排序之后：\");\n        System.out.println(Arrays.toString(arr));\n    }\n}\n```\n## 自顶向下的归并排序java实现\n```java\nprivate static void sort(int[] a, int low, int high) {\n        if (high <= low) return;\n        int mid = low + (high - low) / 2;\n        sort(a, low, mid);\n        sort(a, mid + 1, high);\n        merge(a, low, mid, high);\n    }\n\n    private static void merge(int[] a, int lo, int mid, int hi) {\n        // 复制到aux[]\n        int[] aux = new int[a.length];\n        for (int k = lo; k <= hi; k++) {\n            aux[k] = a[k];\n        }\n        // 合并回 a[]\n        int i = lo, j = mid + 1;\n        for (int k = lo; k <= hi; k++) {\n            if (i > mid) a[k] = aux[j++];\n            else if (j > hi) a[k] = aux[i++];\n            else if (aux[j] < aux[i]) a[k] = aux[j++];\n            else a[k] = aux[i++];\n        }\n    }\n```\n## 算法复杂度\n归并排序的算法复杂度是nlgn\n\n## 应用场景\n1. 几个基本有序的数组进行排序\n2. 部分有序的数组\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["算法"],"categories":["algorithm"]},{"title":"突破算法第三天-希尔排序","url":"/suanfa-3.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n希尔排序平常用的比较少，主要是基于插入排序的改进。但是希尔排序的性能很高，数组越大，性能优势越明显。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 希尔排序的基本原理\n基本思想：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。  \n操作方法：\n1. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1； \n2. 按增量序列个数k，对序列进行k 趟排序； \n3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n![希尔排序原理图](http://o7kalf5h3.bkt.clouddn.com/shellSort.jpg)\n\n## 希尔排序java实现\n```java\n    public static void shellSort(int[] a) {\n        int n = a.length;\n        int h = 1;\n        while (h < n/3) h = 3*h + 1;\n        while (h >= 1) {\n            // h-sort the array\n            for (int i = h; i < n; i++) {\n                for (int j = i; j >= h && (a[j]< a[j-h]); j -= h) {\n                    swap(a, j, j-h);\n                }\n            }\n            h /= 3;\n        }\n    }\n    private static void swap(int[] a, int i, int j) {\n        int swap = a[i];\n        a[i] = a[j];\n        a[j] = swap;\n    }\n```\n## 算法复杂度\n希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，是一个不稳定排序算法\n\n## 适用场景\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["算法"],"categories":["algorithm"]},{"title":"突破算法第二天-插入排序","url":"/suanfa-2.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n今天是突破算法第二天，插入排序，比较简单。效率比较低，但是思想很广泛，应用很广，是很多高级排序算法的一个子过程。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 插入排序的原理\n 将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录\n 看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。\n 要点：设立哨兵，作为临时存储和判断数组边界之用\n\n![插入排序原理](http://o7kalf5h3.bkt.clouddn.com/insert.jpg)\n\n## 插入排序java实现\n```java\n public static void insertSort(int[] a, int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j > 0 && (a[j]<a[j-1]); j--) {\n                swap(a, j, j-1);\n            }\n        }\n    }\n    private static void swap(int[] a, int i, int j) {\n        int swap = a[i];\n        a[i] = a[j];\n        a[j] = swap;\n    }\n```\n## 算法复杂度\n插入排序的复杂度为O（n^2）\n\n## 改进方法\n希尔排序，其他的插入排序有二分插入排序，2-路插入排序。\n\n## 适用场景\n插入排序比较适合部分有序的数组（以下四种数组）\n* 数组中每个元素距离它的最终位置都不远\n* 一个有序的大数组接一个小数组\n* 数组中只有几个位置不正确\n* 数组比较小\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["算法"],"categories":["algorithm"]},{"title":"突破算法第一天-快速排序","url":"/suanfa-1.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n30天突破算法是我给自己定的一个学习计划，希望在这30天，每天都能完成计划。第一天学习最重要的快速排序。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 30天突破算法\n算法种类不计其数，说30天突破只是给自己定的学习计划。目的是通过30天的记录熟悉常见的算法，提高自己的算法能力。对以后的工作来说也是打下夯实的基础。\n\n## 快速排序的原理\n快速排序也是分治法思想的一种实现，他的思路是使数组中的每个元素与基准值（Pivot，通常是数组的首个值，A[0]）比较，数组中比基准值小的放在基准值的左边，形成左部；大的放在右边，形成右部；接下来将左部和右部分别递归地执行上面的过程：选基准值，小的放在左边，大的放在右边。重复此过程，直到排序结束。步骤如下：\n* 1.找基准值，设Pivot = a[0] \n* 2.分区（Partition）：比基准值小的放左边，大的放右边，基准值(Pivot)放左部与右部的之间。\n* 3.进行左部（a[0] - a[pivot-1]）的递归，以及右部（a[pivot+1] - a[n-1]）的递归，重复上述步骤。\n\n![快速排序原理图](http://o7kalf5h3.bkt.clouddn.com/quicksort.jpg)\n\n## 快速排序java实现（递归版）\n```java\npublic class QuickSort {\n    public static void main(String[] args) {\n        int[] a={49,38,65,97,76,13,27,49,78,34,12,64,1,8};\n        System.out.println(\"排序之前：\");\n        for (int i = 0; i < a.length; i++) {\n            System.out.print(a[i]+\" \");\n        }\n        //快速排序\n        quick(a);\n        System.out.println();\n        System.out.println(\"排序之后：\");\n        for (int i = 0; i < a.length; i++) {\n            System.out.print(a[i]+\" \");\n        }\n    }\n\n    private static void quick(int[] a) {\n        if(a.length>0){\n            quickSort(a,0,a.length-1);\n        }\n    }\n\n    private static void quickSort(int[] a, int low, int high) {\n        if(low<high){ //如果不加这个判断递归会无法退出导致堆栈溢出异常\n            int middle = getMiddle(a,low,high);\n            quickSort(a, 0, middle-1);\n            quickSort(a, middle+1, high);\n        }\n    }\n\n    private static int getMiddle(int[] a, int low, int high) {\n        int temp = a[low];//基准元素\n        while(low<high){\n            //找到比基准元素小的元素位置\n            while(low<high && a[high]>=temp){\n                high--;\n            }\n            a[low] = a[high]; \n            while(low<high && a[low]<=temp){\n                low++;\n            }\n            a[high] = a[low];\n        }\n        a[low] = temp;\n        return low;\n    }\n}\n```\n\n## 快速排序三向切分法（改进的实现）\n```java\n    private static void quick3Sort(int[] a, int low, int high) {\n        if (low >= high) return;\n        int lt = low, gt = high;\n        int temp = a[low];\n        int i = low;\n        while (i <= gt) {\n            if (a[i] < temp) swap(a, lt++, i++);\n            else if (a[i] > temp) swap(a, i, gt--);\n            else i++;\n        }\n        quick3Sort(a, low, lt - 1);\n        quick3Sort(a, gt + 1, high);\n    }\n\n    private static void swap(int[] a, int i, int j) {\n        int swap = a[i];\n        a[i] = a[j];\n        a[j] = swap;\n    }\n```\n\n## 快速排序的复杂度\n时间复杂度 nlogn,排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。快速排序是一个不稳定的排序方法。\n\n## 改进方法\n1. 当数组比较小的时候，快速排序比插入排序慢，这个时候用插入排序替换比较好。\n2. 通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录\n\n## 适用场景\n- 普通的无序集合排序，使用快速排序。 \n- 包含很多重复元素的集合排序，使用三向切分的快速排序。\n- 基本有序的集合使用归并排序。\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["算法"],"categories":["algorithm"]},{"title":"学习计划-30天突破算法","url":"/study-plan.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n作为一个非专业出身的程序员，一直对算法的学习赶紧断断续续，终于下定决心对算法做一次详细总结。30天时间把程序员常用算法逐一突破。这次计划更是对自己的一次挑战，希望自己能坚持到最后！\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 学习排序算法的意义\n1. 学会比较算法的性能的方法\n2. 相关的排序能解决类似的问题\n3. 排序算法很多时候是解决问题的第一步\n\n### 排序算法\n1. 快速排序\n2. 插入排序\n3. 希尔排序\n4. 归并排序\n5. 选择排序\n6. 冒泡排序\n7. 堆排序\n8. 桶排序\n9. 排序算法比较\n\n### 树\n1. 二叉树高度和二叉树的遍历\n2. 红黑树\n3. b树\n\n### 查找算法\n1. 二分查找\n2. 二叉查找树\n3. 平衡查找树\n4. 散列表\n\n### 算法思想\n1. 递归（普通递归，尾递归）\n2. 动态规划\n3. 贪婪算法\n4. 分治法\n\n### 图的算法\n1. 深度优先\n2. 广度优先\n3. 最小生成树\n4. 最短路径 \n\n### 字符串算法\n1. 字符串查找\n2. 单词查找树\n3. 子字符串查找\n\n### 典型算法分析\n1. 拓扑排序\n2. 关键路径排序\n3. 遗传算法\n4. RSA算法\n\n\n## 英语技术文档阅读突破\n1. 熟悉常用技术词汇\n2. 阅读常见的技术文档（官网文档看一遍）\n3. 记住常用的词汇\n4. 阅读英文技术书籍\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["algorithm"],"categories":["算法"]},{"title":"用java将GBK工程转为uft8","url":"/trandsferProject.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nwindows下的默认编码为GBK还有gb2312，如何把gbk的java工程转为utf8的呢，如果直接修改工程编码，其实里面的java文件中中文是会乱码的，写了个批量转换java工程的程序，消遣一下。\n<!-- more -->\n<The rest of contents | 余下全文>\n## 为什么要转码？\n有些老的项目，或者朋友的项目之前没注意在windows上不是utf8，而你有需要看注释或者什么，总不能一个文件一个文件的去改编码属性吧。\n\n## 本程序试用范围\ngbk的代码，或者gb2312的工程均可以转换\n\n## 编码转换的思路\n本来想做成一个通用的会自动检测编码，自动转换的程序。但是由于判断编码类型不准，所以做成了针对GBK的转换。\n1. 制定gbk编码把文件流读进来，加载到内存，转为String类型的内容\n2. 将String内容转为utf8的String\n3. 将String内容写入文件\n\n## 核心代码：\n\n```java\npublic class TransferProject {\n    public static void transferFile(String pathName, int depth) throws Exception {\n        File dirFile = new File(pathName);\n        if (!isValidFile(dirFile)) return;\n        //获取此目录下的所有文件名与目录名\n        String[] fileList = dirFile.list();\n        int currentDepth = depth + 1;\n        for (int i = 0; i < fileList.length; i++) {\n            String string = fileList[i];\n            File file = new File(dirFile.getPath(), string);\n            String name = file.getName();\n            //如果是一个目录，搜索深度depth++，输出目录名后，进行递归\n            if (file.isDirectory()) {\n                //递归\n                transferFile(file.getCanonicalPath(), currentDepth);\n            } else {\n                if (name.contains(\".java\") || name.contains(\".properties\") || name.contains(\".xml\")) {\n                    readAndWrite(file);\n                    System.out.println(name + \" has converted to utf8 \");\n                }\n            }\n        }\n    }\n\n    private static boolean isValidFile(File dirFile) throws IOException {\n        if (dirFile.exists()) {\n            System.out.println(\"file exist\");\n            return true;\n        }\n        if (dirFile.isDirectory()) {\n            if (dirFile.isFile()) {\n                System.out.println(dirFile.getCanonicalFile());\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private static void readAndWrite(File file) throws Exception {\n        String  content = FileUtils.readFileByEncode(file.getPath(), \"GBK\");\n        FileUtils.writeByBufferedReader(file.getPath(), new String(content.getBytes(\"UTF-8\"), \"UTF-8\"));\n    }\n\n    public static void main(String[] args) throws Exception {\n        //程序入口，制定src的path\n        String path = \"/Users/mac/Downloads/unit06_jdbc/src\";\n        transferFile(path, 1);\n    }\n}\n```\n\n```java\npublic class FileUtils {\n    public static void writeByBufferedReader(String path, String content) {\n        try {\n            File file = new File(path);\n            file.delete();\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n\n            FileWriter fw = new FileWriter(file, false);\n            BufferedWriter bw = new BufferedWriter(fw);\n            bw.write(content);\n            bw.flush();\n            bw.close();\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public static String readFileByEncode(String path, String chatSet) throws Exception {\n        InputStream input = new FileInputStream(path);\n        InputStreamReader in = new InputStreamReader(input, chatSet);\n        BufferedReader reader = new BufferedReader(in);\n        StringBuffer sb = new StringBuffer();\n        String line = reader.readLine();\n        while (line != null) {\n            sb.append(line);\n            sb.append(\"\\r\\n\");\n            line = reader.readLine();\n        }\n        return sb.toString();\n    }\n}\n```\n## 总结\n遇到类似的问题，都可以试着用代码来进行实现，给自己的编码带来一些新的乐趣，也增加自己的信心。\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["java"],"categories":["编程语言"]},{"title":"阿拉伯数字转汉字写法","url":"/num2Chinese.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n找工作时看到“某团”的题目，把一个int的数字转为汉字的读法，比如123，转成一百二十三，限时20分钟。如果二十分钟做不出来，简历就不要投了。说实话，20分钟能调通的人真的不多，感觉某团还是装逼成分太多！\n<!-- more -->\n<The rest of contents | 余下全文>\n## 题目要求\n用java实现，把int的数字转为汉字读音，比如123，转成一百二十三，10020转为一万零二十\n\n## 思路分析\n中文计数的特点，以万为小节，万以内的都是以“十百千”为权位单独计数，比如一千百，一千千都是非法的。\n而“十百千”这样的权位可以与“万”，“亿”进行搭配，二十亿，五千万等等。\n\n## 中文数字的零\n中文的零的使用总结起来有三个规则，\n* 以10000为小节，结尾是0，不使用零，比如1020\n* 以10000为小节，小节内两个非0数字之间需要零\n* 小节的千位是0，若小节前无其他数字，不用零，否者用零\n\n## 完整代码（参考算法的乐趣第四章）\n\n```java\npublic class NumberTransfer {\n    public final String[] chnNumChar = new String[]{\"零\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\", \"七\", \"八\", \"九\"};\n    public final String[] chnUnitSection = new String[]{\"\", \"万\", \"亿\", \"万亿\"};\n    public final String[] chnUnitChar = new String[]{\"\", \"十\", \"百\", \"千\"};\n\n    @Test\n    public void testNumberToChinese() {\n        int[] nums = new int[]{304, 4006, 4000, 10003, 10030, 21010011, 101101101};\n        for (int i = 0; i < nums.length; i++) {\n            System.out.println(numberToChinese(nums[i]));\n        }\n    }\n\n    public String numberToChinese(int num) {\n        String strIns;\n        String chnStr = \"\";\n        int unitPos = 0;\n        boolean needZero = false;\n        if (num == 0)\n            return \"零\";\n        while (num > 0) {\n            strIns = \"\";\n            int section = num % 10000;\n            if (needZero) {\n                chnStr = chnNumChar[0] + chnStr;\n            }\n            // 添加节权（万，亿）\n            strIns += (section != 0) ? chnUnitSection[unitPos] : chnUnitSection[0];\n            chnStr = strIns + chnStr;\n            // 以万为单位，求万以内的权位\n            chnStr = sectionToChinese(section, chnStr);\n            needZero = (section < 1000) && (section > 0);\n            num = num / 10000;\n            unitPos++;\n        }\n        return chnStr;\n    }\n\n    private String sectionToChinese(int section, String chnStr) {\n        String strIns;\n        int unitPos = 0;\n        boolean zero = true;\n        while (section > 0) {\n            int v = section % 10;\n            if (v == 0) {\n                if (section == 0 || !zero) {\n                    zero = true;// zero确保不会出现多个零\n                    chnStr = chnNumChar[v] + chnStr;\n                }\n            } else {\n                zero = false;\n                strIns = chnNumChar[v]; // 此位置对应等中文数字\n                strIns += chnUnitChar[unitPos];// 此位置对应的权位\n                chnStr = strIns + chnStr;\n            }\n            unitPos++;\n            section = section / 10;\n        }\n        return chnStr;\n    }\n}\n```\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["算法"],"categories":["algorithm"]},{"title":"Java面试大全自制版","url":"/java-interview.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\njava语言知识点多而杂，面试时很多人找不到重点。这份java面试大全，有部分网络上资源，大多数是从好的文章和书籍里总结出来的知识点。\n<!-- more -->\n<The rest of contents | 余下全文>\n## 本书的目的\n每个java程序员在面试前都不知该准备什么？或者是随便看几个文章就去面试，这样的结果很容易失败！希望本书能给java程序员一个好的指引，让java程序员没有难找的工作！\n\n## 目录\n[gitbook地址](https://maochunguang.gitbooks.io/java-interview/)\n![目录截图](http://o7kalf5h3.bkt.clouddn.com/java-tips.png)\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["java"],"categories":["学习笔记"]},{"title":"Kobo Aura One导出笔记高级配置","url":"/kobo-config.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nkobo电子书折腾记，导出笔记，从激活到设置，打补丁实现自定义配置，还是自己折腾起来有意思啊。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 建议\n买电子书是为了阅读和学习，不是天天折腾电子书，一天刷一次机，如果只是看书，做笔记，学个英文什么的\n原生系统是最好的。如果看pdf为主，不建议买这电子书，看pdf首选电脑，平板，sony dsp系列，用普通的电子书阅读器，体验太差。\n\n## kobo原生系统的功能（推荐原生系统，打上补丁）\n1. 格式支持epub，mobi，cbz漫画，txt，kobo epub格式\n2. 高亮，笔记，导出笔记（需要配置一下）\n3. 字典（英文，中文，法文等多国字典，可以自己修改）\n4. 阅读pocket文章（可以把网页保存到pocket，实用pocket同步到阅读器）\n5. 自动亮度（最大的优点）\n\n## koreader的功能\n1. 格式支持epub，mobi，cbz漫画，txt，kobo epub格式\n2. 扫描版pdf支持重拍，切边（最大特色）\n3. 笔记导出到印象笔记\n4. 字典（强大的字典扩展）\n\n\n## 激活\n**说明：wifi激活需要翻墙，可以实用笔记连接vpn，然后共享wifi给kobo**\n1. wifi激活,\n2. kobo setup desktop激活，去kobo官网下载软件，然后电脑需要翻墙，电子书连接上电脑，用软件登录激活。这个软件很不好用，bug也多，建议使用wifi激活。\n\n## 更新固件，打补丁\nkobo的更新固件，更新补丁都是一个模式，把固件或者补丁放到.kobo文件夹，弹出设备就会自动重启\n\n## 字体\n电脑连接kobo，在根目录建立一个fonts文件夹，把需要的字体放进去即可\n\n## 词典\n下载网上改好的字典，直接放到.kobo文件夹下的dict目录下，然后重启就可以了\n\n## 自定义配置\n1. 刷新页数（打补丁）\n2. 上下页宽（打补丁）\n3. 全屏模式（修改配置文件）\n4. 字体高级设置（修改配置文件）\n5. 导出笔记和高亮（修改配置文件）\n\n## kobo高级配置文件详解\n用电脑连接kobo电子书，打开Kobo找到eReader.conf文件，最好用notepad++修改，或者其他文本编辑器。\n```conf\n[FeatureSettings]\n#导出笔记\nExportHighlightsEnabled=true\n#显示全书的页码，而不是章节的页码\nFullBookPageNumbers=true\n#用在线等维基百科代替词典查询\nOnlineWikipedia=true\n#全屏阅读\nFullScreenReading=true\n#图片缩放\nImageZoom=true\n#浏览器全屏\nFullScreenBrowser=true\n#关机键截图，但是关机键就无法关机了，不要设置这个鸡肋的功能\nScreenshots=true\n[Reading]\n#翻页刷新的页数，20页全刷一次\nnumPartialUpdatePageTurns=20\n#左边距\nreadingLeftMargin=0\n#右边距\nreadingRightMargin=0\n#行高\nreadingLineHeight=1.4\n\n[PowerOptions]\n#自动关机时间\nAutoOffMinutes=60\n```\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["开发工具"],"categories":["others"]},{"title":"Illegal Mix of Collations","url":"/mysql-collation.html","content":"** mysql排序字符集问题：** <Excerpt in index | 首页摘要>\nmysql表的每个字段都可以设置单独的排序字符集和文本字符集，如果你创建表的时候不注意，很可能会遇到Illegal mix of collations这个问题。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 问题描述\n用mysql进行两个表的联合查询的时候，出现下面的错误。\n```\nIllegal mix of collations (utf8_unicode_ci,IMPLICIT) and (utf8_general_ci,IMPLICIT) for operation '='\n```\n## 排查过程\n1. 通过google搜索找到原因，这个错误是mysql的排序字符集不一致导致的。\n2. 把联合查询的表使用navicat查看字段的设置，发现了有一个关联字段排序字符集的问题，如图：\n3. 这两个表中openid的排序规则不一致，导致出现问题。\n![user表中opeid](http://o7kalf5h3.bkt.clouddn.com/openid01.png)\n![user_tag表中opeid](http://o7kalf5h3.bkt.clouddn.com/openid02.png)\n\n## 解决方法\n将user表中的字符集和排序规则设置为默认，保持一致即可。\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["mysql"],"categories":["数据库"]},{"title":"如何选购合适的电脑","url":"/buy-computer.html","content":"** 购买合适的电脑：** <Excerpt in index | 首页摘要>\n现代的生活中每个人都已经离不开电脑了，打游戏，看电影，办公，等等。购买一个合适的电脑显得尤为重要，电脑不舒服，用着影响心情。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 买电脑主要干什么\n1. 看电影，上网\n2. 打游戏\n3. 办公（移动办公）\n4. 平面设计（二维）\n5. 编程（ios和其它，深度学习）\n6. 效果图渲染（3维制图）\n\n## 电脑配置说明\n目前电脑配置的cpu，内存都很高，显卡也很好，而普通电脑的瓶颈都是在硬盘上，所以一台普通电脑换上固体硬盘体验立即上了一个档次，所以现在买电脑不带固态硬盘没法玩的。这里我之列一些主要配置，至于买笔记本还是台式机个人喜好。台式机性能肯定远超同价位笔记本，这个是毋庸置疑的。\n\n## 看电影，上网\n看电影上网，对电脑配置要求比较低的，一般普通双核cpu，amd的，酷睿i3都不在话下，内存的话4g够用，8g就浪费了。买笔记本或者台式机都可以  \n推荐配置1：i3处理器，4g内存，128固态，整体价位3000-4000左右  \n推荐配置1：i5处理器，4g内存，256固态\n\n## 打游戏\n游戏主机是最烧钱的，其实游戏主机的cpu要求一般，主要在显卡，内存上。建议买台式机\n* 一般的主流网游：i5或i7处理器，内存8g，显卡的话中端显卡就ok，硬盘128ssd+1Thdd起\n* 大型单机：i5或i7处理器，内存16g，，显卡中高端gtx960，970即可，硬盘128ssd+1Thdd起\n* 发烧友：i7处理器，内存32g，显卡高端gtx1060以上，硬盘512ssd+1Thdd起\n\n## 办公\n很多商务人士需要携带笔记本，其实对笔记本的性能要求一般，但是便携性要求很高，用超极本最合适的，  推荐配置：4g内存，256ssd，i5即可\n\n## 平面设计\n使用ps，ae之类的软件居多，对内存和cpu要求较高，显卡一般即可\n推荐配置1：16g内存，i7处理器，256ssd，2k／4k专业显示器，中端显卡即可\n推荐配置2：macbookpro15 16g，512ssd，i7处理器\n\n## 编程\n这里应该分为两类：做mac，ios开发之类的肯定得首选macbookpro，而做windows软件开发肯定windows好一些。个人推荐mac的笔记本做编程，一用就停不下来，会上瘾。  \n推荐配置1：macbookpro15 16g，512ssd，i7处理器  \n推荐配置2：i7处理器，16g内存，512ssd，中端显卡\n\n## 效果图渲染（3维制图）\n这个是专业领域的需求，对显卡和内存，cpu要求都较高，肯能需要双显卡。    \n推荐配置1：至强处理器，32g内存，512ssd+1Thdd  \n推荐配置2：i7处理器，32g内存，512ssd+1Thdd\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["数码产品"],"categories":["digital"]},{"title":"Mongodb从入门到精通","url":"/mongodb-study.html","content":"** mongodb从入门到精通** <Excerpt in index | 首页摘要>\n    mongodb日常使用的一些知识，增删改查，索引，分片。\n <!-- more -->\n<The rest of contents | 余下全文>\n\n## mongodb学习\n## 1.mongodb特性\n    1）mongo是一个面向文档的数据库，它集合了nosql和sql数据库两方面的特性。\n    2）所有实体都是在首次使用时创建。\n    3）没有严格的事务特性，但是它保证任何一次数据变更都是原子性的。\n    4）也没有固定的数据模型\n    5）mongo以javascript作为命令行执行引擎，所以利用shell进行复杂的计算和查询时会相当的慢。\n    6）mongo本身支持集群和数据分片\n    7）mongo是c++实现的，支持windows mac linux等主流操作系统\n    8）性能优越，速度快\n## 2.mongo常用操作\n### 增删操作\n```js\ndb.user.insert({name:'aaaa',age:30});\ndb.user.save({name:'aaaa',age:30});\ndb.collection.insertOne({});//(3.2新特性)\ndb.collection.deleteOne({},{});//(3.2新特性)\ndb.collection.remove({name:'aaa'});\ndb.collection.remove();//(删除全部)\n```\n### 更新操作\n```js\ndb.users.update({\"name\": \"joe\"}, joe );\n//upsert模式\ndb.users.update({\"name\": \"joe\"}, joe,  true );\n//MULTI模式\ndb.users.update({\"name\": \"joe\"}, joe,  true ，true);\n```\n> update是对文档替换，而不是局部修改默认情况update更新匹配的第一条文档，multi模式更新所有匹配的  \n\n### 查询操作\n普通查询\n```js\ndb.user.find();\ndb.user.find({name:'aaa'});\ndb.user.findOne({name:'aaa'});\n```\n模糊查询\n```js\ndb.UserInfo.find({userName :'/A/'}) //（名称%A%）\ndb.UserInfo.find({userName :'/^A/'}) //(名称A%)\n```\n### 操作符\n1. $lt, $lte,$gt, $gte(<, <=, >, >= ) \t\n2. $all\t数组中的元素是否完全匹配  db.things.find( { a: { $all: [ 2, 3 ] } } );\n3. $exists  可选：true，false  db.things.find( { a : { $exists : true } } );\n4. $mod  取模：a % 10 == 1  db.things.find( { a : { $mod : [ 10 , 1 ] } } );\n5. $ne 取反：即not equals  db.things.find( { x : { $ne : 3 } } );\n6. $in 类似于SQL的IN操作  db.things.find({j:{$in: [2,4,6]}});\n7. $nin $in的反操作，即SQL的  NOT IN  db.things.find({j:{$nin: [2,4,6]}});\n8. $nor $or的反操作，即不匹配(a或b)  db.things.find( { name : \"bob\", $nor : [ { a : 1 },{ b : 2 }]})\n9. $or Or子句，注意$or不能嵌套使用  db.things.find( { name : \"bob\" , $or : [ { a : 1 },{ b : 2 }]})\n10. $size  匹配数组长度  db.things.find( { a : { $size: 1 } } );\n11. $type  匹配子键的数据类型，详情请看  db.things.find( { a : { $type : 2 } } );\n\n### 数组查询\n$size 用来匹配数组长度（即最大下标）  \n// 返回comments包含5个元素的文档   \ndb.posts.find({}, {comments:{‘$size’: 5}});  \n// 使用冗余字段来实现  \ndb.posts.find({}, {‘commentCount’: { ‘$gt’: 5 }});   \n$slice 操作符类似于子键筛选，只不过它筛选的是数组中的项  \n// 仅返回数组中的前5项  \ndb.posts.find({}, {comments:{‘$slice’: 5}});  \n// 仅返回数组中的最后5项  \ndb.posts.find({}, {comments:{‘$slice’: -5}});  \n// 跳过数组中的前20项，返回接下来的10项  \ndb.posts.find({}, {comments:{‘$slice’: [20, 10]}});  \n// 跳过数组中的最后20项，返回接下来的10项  \ndb.posts.find({}, {comments:{‘$slice’: [-20, 10]}});  \nMongoDB 允许在查询中指定数组的下标，以实现更加精确的匹配  \n// 返回comments中第1项的by子键为Abe的所有文档  \ndb.posts.find( { \"comments.0.by\" : \"Abe\" } );   \n## 3.索引的使用\n### 创建索引\n```js\ndb.things.ensureIndex({'j': 1});\n//创建子文档 索引\ndb.things.ensureIndex({'user.Name' : - 1});\n//创建 复合 索引\ndb.things.ensureIndex({\n'j' : 1 ,   //  升序\n'x' : - 1   //  降序\n});\n```\n如果 您的 find 操作只用到了一个键，那么索引方向是无关紧要的  \n\t\t当创建复合索引的时候，一定要谨慎斟酌每个键的排序方向\n\n### 修改索引\n修改索引，只需要重新 运行索引 命令即可  \n如果索引已经存在则会 重建， 不存在的索引会被 添加  \n```js\ndb.things.ensureIndex ({\n\t//原来的索引会 重建\n\t'user.Name ' : - 1 ,\n\t//新增一个升序 索引\n\t'user.Name ' : 1 ,\n\t//为 Age 新建降序 索引\n\t'user.Age ' :  - 1\n\t//打开后台执行\n},{\t'background' :   true});\n//重建索引\ndb.things.reIndex();\n```\n### 删除索引\n```js\n//删除集合中的所有 索引\ndb.things.dropIndexes ();  \n//删除指定键的索引  \ndb.things.dropIndex ({\n\tx :   1 ,\n\ty :   - 1\n});  \n//使用 command 删除指定键的 索引\ndb.runCommand ({\n\tdropIndexes : 'foo ' ,\n\tindex:{ y : 1 }\n});  \n//使用 command 删除所有 索引\ndb.runCommand ({dropIndexes : 'foo ',index: '*'})\n```\n如果是删除集合中所有的文档（remove）则不会影响索引，当有新文档插入时，索引就会重建。\n\n### 唯一索引\n创建唯一索引，同时这也是一个符合唯一索引  \n```js\ndb.things.ensureIndex (\n{\n\t'firstName ' :   1 ,\n\t'lastName ' :   1\n},   {\n//指定为唯一索引\n'unique': true ,\n//删除重复 记录\n'dropDups': true\n});\n```\n### 强制使用索引\n```js\n//强制使用索引 a 和 b\ndb.collection.find({\n\t'a' :   4 ,\n\t'b' :   5 ,\n\t'c' :   6\n}).hint({\n\t'a' :   1 ,\n\t'b' :   1\n});\n//强制不使用任何 索引\ndb.collection.find().hint({\n\t'$natural' :   1\n});\n```\n----------\n索引总结:\n* 索引可以加速查询；\n* 单个索引无需在意其索引方向；\n* 多键索引需要慎重考虑每个索引的方向；\n* 做海量数据更新时应当先卸载所有索引，待数据更新完成后再重建索引；\n* 不要试图为每个键都创建索引，应考虑实际需要，并不是索引越多越好；\n* 唯一索引可以用来消除重复记录；\n* 地理空间索引是没有单位的，其内部实现是基本的勾股定理算法\n\n\n## 4.mongo数据库管理\n### 安全与认证\n1. 默认为无认证，启动用登录 shell ；\n2. 添加账号；\n3. 关闭 shell .关闭 MongoDB ；\n4. 为 MongoDB 增加 — auth 参数；\n5. 重 启 MongoDB ；\n6. 登录 shell ，此时就需要认证了\n\n### 冷备份\n1. 关闭MongoDB引擎\n2. 拷贝数据库文件夹及文件\n3. 恢复时反向操作即可\t\t\n* 优点：可以完全保证数据完整性；\n* 缺点：需要数据库引擎离线 \t\n### 热备份\n1.  保持MongoDB为运行状态\n2. 使用mongodump备份数据\n3. 使用mongorestore恢复数据\n* 优点：数据库引擎无须离线\n* 缺点：不能保证数据完整性，操作时会降低MongoDB性能\n\n### 主从复制备份\n1. 创建主从复制机制\n2. 配置完成后数据会自动同步\n3. 恢复途径很多\n* 优点：可以保持MongoDB处于联机状态，不影响性能\n* 缺点：在数据写入密集的情况下可能无法保证数据完整性\n\n### 修复db.repairDatabase();\n* 修复数据库还可以起到压缩数据的作用；\n* 修复数据库的操作相当耗时，万不得已请不要使用；\n* 建议经常做数据备份；\n## 5.mongo复制(集群)\n1. 主从复制\n选项  \t说明\n--only  作用是限定仅复制指定的某个数据库\n--slavedelay  为复制设置操作延迟，单位为秒\n--fastsync  以主节点的数据快照为基础启动从节点。\n--autoresync  当主从节点数据不一致时，是否自动重新同步\n--oplogSize  设定主节点中的oplog的容量，单位是MB\n\n2. 副本集\n与普通主从复制集群相比，具有自动检测机制\n需要使用—replSet 选项指定副本同伴\n任何时候，副本集当中最多只允许有1个活跃节点\n\n3. 读写分离\n将密集的读取操作分流到从节点上，降低主节点的负载\n默认情况下，从节点是不允许处理\n客户端请求的，需要使用—slaveOkay打开\n不适用于实时性要求非常高的应用\n\n4. 工作原理—— OPLOG\noplog保存在local数据库中，oplog就在其中的\noplog.$main集合内保存。该集合的每个文档都记录了主节点上执行的一个操作，其键定义如下：\n\tts：操作时间戳，占用4字节\n\top：操作类型，占用1字节\n\tns：操作对象的命名空间（或理解为集合全名）\n\to：进一步指定所执行的操作，例如插入\n\n5. 工作原理—— 同步\n\t从节点首次启动时，做完整同步\n\t主节点数据发生变化时，做增量同步\n\t从节点与主节点数据严重不一致时，做完整同步\n\n6. 复制管理—— 诊断\ndb.printReplicationInfo()\n在主节点上使用\n\t返回信息是oplog的大小以及各种操作的耗时. 空间占用等数据\n在从节点上使用\ndb.printSlaveReplicationInfo()\n\t返回信息是从节点的数据源列表. 同步延迟时间等\n\n7. 复制管理—— 变更OPLOG 容量\n在主节点上使用\n\t设定—oplogSize参数\n\t重启MongoDB\n\n8. 复制管理—— 复制认证\n主从节点皆须配置\n\t存储在local.system.users\n\t优先尝试repl用户\n\t主从节点的用户配置必须保持一致\n## 6.MONGODB分片\n### 分片与自动分片\n分片是指将数据拆分，分散到不同的实例上进行负载分流的做法。我们常说的“分表”、“分库”、“分区”等概念都属于分片的实际体现。\n传统分片做法是手工分表、分库。自动分片技术是根据指定的“片键”自动拆分数据并维护数据请求路由的过程。\n\n* 递增片键--连续 不均匀 写入集中 分流较差\n* 随机片键--不连续 均匀 写入分散 分流较好\n\n### 三个组成部分\n* 片,保存子集数据的容器\n* mongos,MongoDB的路由器进程\n* 配置服务器,分·片集群的配置信息\n### 创建分片\n* --启动配置服务器,可以创建一个或多个\n* --添加片,每个片都应该是副本集\n* --物理服务器,性能、安全和稳定性\n### 管理分片\n```js\n//查询分片\ndb.shards.find();\n//数据库\ndb.databases.find();\n//块\ndb.chunks.find();\n//分片状态\ndb.printShardingStatus();\n//删除片\ndb.runCommand({ removeshard : 'ip:port' });\n```\n","tags":["mongodb"],"categories":["数据库"]},{"title":"Hexo自用黑色主题","url":"/hexo-theme.html","content":"** hexo和coding打造静态博客 ：** <Excerpt in index | 首页摘要\\>\n使用hexo一年有余，对所有主题都感觉有所缺陷，便修改了一个自用黑色主题，本主题以黑色和蓝色为主，色彩鲜明，主题明确。\t\n<!-- more -->\n<The rest of contents | 余下全文\\>\n\n## 主题图片\n![主题首页](http://o7kalf5h3.bkt.clouddn.com/blog-index.png) \n\n## black-blue主题来源\n本主题修改自**spfk**主题，但之前spfk主题有很多问题，本主题改进如下：\n1. 压缩js，css提高性能\n2. 代码段样式显示更完美\n3. 增加本地搜索\n4. 设置更合适的字体大小\n5. 颜色以黑色和蓝色为主，色彩鲜明\n6. seo适当优化\n7. 删除多说，有言，增加畅言评论\n8. 删除stylus，全部改用css方便修改\n\n## 主题地址\n[black-blue](https://github.com/maochunguang/black-blue)\n\n## 注意：\n大家使用主题的时候，把**主题配置文件_config.yml**以下几项必须修改，项目里实用的是我博客的正式代码，请大家修改成自己的！\n```yml\ngoogle_analytics: xxx\nbaidu_analytics: xxxxxxx\ndisqus:\n  on: false\n  shortname: xxxx\n# 畅言评论\nchangyan:\n  on: true\n  appid: xxxx\n  conf: xxxxx\n\n```\n## black-blue主题配置\n### 切换主题\n复制主题到themes目录下`cd themes && git clone https://github.com/maochunguang/black-blue`，修改_config.yml `theme: black-blue`\n\n### 安装常用插件，建议全部安装\n```bash\n## rss插件\nnpm install hexo-generator-feed --save\n## 站点sitemap生成插件\nnpm install hexo-generator-sitemap --save\nnpm install hexo-generator-baidu-sitemap --save\n## 百度url提交\nnpm install hexo-baidu-url-submit --save\n## 本地搜索插件集成\nnpm install hexo-generator-search --save\n```\n### 博客全局配置，修改根目录下_config.yml\n插件配置\n```yml\nPlugins:\n- hexo-generator-feed\n- hexo-generator-sitemap\n- hexo-generator-baidu-sitemap\n```\nrss设置\n```yml\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n```\n本地搜索配置\n```yml\nsearch:\n  path: search.json\n  field: post\n```\n站点地图，seo搜索引擎需要\n```yml\nsitemap:\n  path: sitemap.xml\nbaidusitemap:\n  path: baidusitemap.xml\n```\n### 主题配置\n菜单配置\n```yml\n## 添加单独的页面:hexo new page about，about是页面的路径，也是名称\n## Tags Cloud Page: `hexo new page tags`\nmenu:\n  # 主页: /archives/\n  所有文章: /archives/\n  玩转开发工具: /categories/开发工具/\n  玩转数码: /categories/digital\n  认知提升: /categories/cognition\n  关于我: /about/\n```\n评论配置\n```yml\n# 是否开启畅言评论，\nchangyan:\n  on: true\n  appid: xxxx\n  conf: xxxxxxxxxxxx\n# 是否开启disqus，\ndisqus:\n  on: false\n  shortname: mmmmmm\n```\n\n### 其他配置，**详细的配置请下载主题，都有注释**\n```yml\n# 数学公式支持\nmathjax: false\n# Socail Share | 是否开启分享\nbaidushare: true\n# 谷歌分析，百度分析，seo分析很有用\ngoogle_analytics: xxxxxx\nbaidu_analytics: xxcxcxcsdsf\n\n```\n## 自定义配置（对前端技术有了解即可）\n### 显示更多和折叠文章\n你的md文件格式需要按下面的来：\n```\ntitle: 突破算法第11天-红黑树\ndate: 2017-10-30 22:35:37\ntags: 算法\ncategories: algorithm\n---\n** {{ title }}：** <Excerpt in index | 首页摘要>\n红黑树\n<!-- more -->\n<The rest of contents | 余下全文>\n正文……\n```\n\n### 头像配置\n在themes/black-blue/source/img/avatar.png,替换此头像即可实现自定义头像\n\n### 背景图片配置\n在themes/black-blue/source/background/,替换为自己喜欢的图片，图片名称不能改\n\n### 添加评论插件\n比如把畅言替换为有言\n1. 先修改themes/black-blue/_config.yml文件\n```yml\nchangyan:\n  on: true\n  uid: xxxxxxx\n```\n2. 修改themes/black-blue/layout/_partial/comments/changyan.ejs\n```js\n<section class=\"changyan\" id=\"comments\">\n<div id=\"uyan_frame\"></div>\n<script type=\"text/javascript\" src=\"http://v2.uyan.cc/code/uyan.js?uid=<%= uid%>\">\n</script>\n</section>\n```\n3. 修改themes/black-blue/layout/_partial/article.ejs\n```js\n<%- partial('comments/changyan', {\n  uid: theme.changyan.uid\n}) %>\n```\n4. 重新生成页面`hexo g`\n","tags":["hexo"],"categories":["开发工具"]},{"title":"数码产品选购","url":"/digital-info.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n作为一个数码产品控，一出新的的电子产品，我都欣喜若狂。看参数，看评价，感觉合适，就会买。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 我喜欢的电子产品\n* 电脑（笔记本，台式机，游戏主机，工作站）\n* 手机（苹果，安卓，其它智能手机）\n* 平板（安卓平板，ios平板）\n* 电子书阅读器\n* 电子手表\n\n## 选购的原则\n1. 产品生态，买电子产品虽然不是随大流，但是用户群体一定程度决定了生态。用的人多，相应的资源会比较丰富，遇到问题很快找到解决方案。\n2. 产品价格，性价比在中国，乃至全世界都是很具有吸引力的。物美价廉的都不买的要么是脑残，要么是钱多没地方花。\n3. 产品硬件参数，买电子产品不看参数，肯定是买不到物美价廉的产品。\n4. 产品外观，现在是看脸的时代，新时代的数码产品对外观要求更高，更时尚。\n5. 功能，买电子产品，首要的就是功能，如果功能都不齐全，再漂亮，再便宜都没用。\n6. 买电子产品的目的，没有任何需求就是瞎买。\n\n## 电子产品的使用\n我见过很多人买电子产品，比如买电子书阅读器，买一个kobo电子书折腾来折腾去，今天刷这个系统，明天改那个设置，\n书还没读几本，系统刷了几十次，天天刷固件。这真的是得不偿失，捡了芝麻丢了西瓜。\n第一，买电子产品是为了用的，买回来之后配置好之后，就不要来回折腾系统和配置了，把时间放到核心功能上。\n第二，买电子产品不要攀比，就跟买苹果手机一样，如果只是为了装B买，真没必要，结果自己还用不习惯。\n第三，了解自己的需求，需要什么买什么，\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["数码产品"],"categories":["digital"]},{"title":"如何写一篇好博客？","url":"/bestblog.html","content":"** 提高自己博客的质量：** <Excerpt in index | 首页摘要>\n写博客陆陆续续也有一年了，但是一直没有多少访问量，仔细看了很多大神的博客，总结了几点，分享一下。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 好博客，好文章是什么样的？\n1. 文章名称鲜明，一看名称就知道关于什么的内容\n2. 整体结构清晰，把事件或者原理的始末按照‘什么样（what？）’，‘为什么（why）’，‘怎么做（how）’说明\n3. 简明扼要。太啰嗦，没人看。\n4. 难易适中，太高深也没人看\n5. 图文搭配，有句话说的好，**一图胜千文**，好的图片胜过千言万语\n\n## 怎么写出好博客？\n1. 定主题和文章名称。如果想写一个关于redis后台启动的文章，名称要准确，就叫redis后台启动，不要起啰嗦的名字，比如redis如何后台启动\n2. 准备资料阶段，熟悉redis配置相关资料，做好功课\n3. 定文章的结构和提纲。还拿这个redis后台启动为例，你得说明什么是后台启动？为什么要后台启动？如何做到后台启动？\n4. 语言表单，简单直白，不用凑字数\n5. 深入主题，比如挖掘更多redis的配置，把参数简要说明\n6. 找一个好图片，如果找不到，自己制作一个最契合自己主题的图片\n7. 把文章发给好友阅读，提出宝贵的意见\n8. 改进博客\n9. 坚持写博客\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["others"],"categories":["个人随笔"]},{"title":"Redis后台启动详细配置","url":"/redis-config.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n  redis启动的时候有多种模式，后台启动，集群启动等等。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 说明\n在开发中一般都是在命令行中直接运行`redis-server`,但是这样命令行关闭，服务就停止了。\n如果要在后台运行redis服务，需要制定配置文件。这里以**ubuntu14**为例子\n\n## 准备配置文件\n查看‘/etc/redis/redis.conf’,没有可以创建一个，或者下载一个，配置文件位置没有要求\n\n## 修改配置文件\n把daemonize设置为yes，\n然后`redis-server /etc/redis/redis.conf`启动服务，\n\n## 查看服务\n`ps -ef|grep redis-server`查看是否有redis进程存在\n\n## 更多配置，在conf文件有说明\n```\n# 是否以后台daemon方式运行，默认是 no，一般我们会改为 yes\ndaemonize no\npidfile /var/run/redis.pid\n# 只允许本机访问\nbind 127.0.0.1\n# 端口设置\nport 6379\ntcp-backlog 511\ntimeout 0\ntcp-keepalive 0\nloglevel notice\n# 日志文件\nlogfile \"\"\n# 开启数据库的数量，Redis 是有数据库概念的，默认是 16 个，数字从 0 ~ 15\ndatabases 16\nsave 900 1\nsave 300 10\nsave 60 10000\nstop-writes-on-bgsave-error yes\nrdbcompression yes\nrdbchecksum yes\ndbfilename dump.rdb\ndir ./\nslave-serve-stale-data yes\nslave-read-only yes\nrepl-diskless-sync no\nrepl-diskless-sync-delay 5\nrepl-disable-tcp-nodelay no\n# 密码设置，需要设置密码打开\nrequirepass 123455\nslave-priority 100\nappendonly no\nappendfilename \"appendonly.aof\"\nappendfsync everysec\nno-appendfsync-on-rewrite no\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\naof-load-truncated yes\nlua-time-limit 5000\nslowlog-log-slower-than 10000\nslowlog-max-len 128\nlatency-monitor-threshold 0\nnotify-keyspace-events \"\"\nhash-max-ziplist-entries 512\nhash-max-ziplist-value 64\nlist-max-ziplist-entries 512\nlist-max-ziplist-value 64\nset-max-intset-entries 512\nzset-max-ziplist-entries 128\nzset-max-ziplist-value 64\nhll-sparse-max-bytes 3000\nactiverehashing yes\nclient-output-buffer-limit normal 0 0 0\nclient-output-buffer-limit slave 256mb 64mb 60\nclient-output-buffer-limit pubsub 32mb 8mb 60\nhz 10\naof-rewrite-incremental-fsync yes\n```\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["redis"],"categories":["数据库"]},{"title":"用koa2.x写下载漫画的爬虫","url":"/spider-koa2.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n使用koa2.x的async ，await解决异步问题，写一个下载漫画的爬虫，代码里有惊喜和福利哦！\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 项目搭建\n1. 安装nodejs>7.6,安装koa-generator\n2. 直接`koa2 spider`,生成项目\n3. 安装request,request-promise,cheerio,mkdirp\n4. npm install安装依赖\n\n## 思路\n图片或者漫画爬虫的思路很简单，首先观察url的规律，把url按规律加入到下载任务，其实就是请求获得html内容，然后对html进行解析，找到下载的图片url（一般都是img标签的src属性值），把url放到数组保存，使用async await控制所有的任务，直到把所有的图片下载完。\n\n## 难点\n但是nodejs本身上异步的，如果你直接在for循环里去下载，肯定是不行的，必须控制好异步的执行上关键。\n爬虫简单，处理好异步难。这里我使用的es7中async，await配合promise解决异步问题，还可以使用async模块，eventproxy，等等异步控制模块来解决。\n\n## 核心代码,spider.js\n```js\nconst fs = require('fs');\nconst request = require(\"request-promise\");\nconst cheerio = require(\"cheerio\");\nconst mkdirp = require('mkdirp');\nconst config = require('../config');\nexports.download = async function(ctx, next) {\n    const dir = 'images';\n    // 图片链接地址\n    let links = [];\n    // 创建目录\n    mkdirp(dir);\n    var urls = [];\n    let tasks = [];\n    let downloadTask = [];\n    let url = config.url;\n    for (var i = 1; i <= config.size; i++) {\n        let link = url + '_' + i + '.html';\n        if (i == 1) {\n            link = url + '.html';\n        }\n        tasks.push(getResLink(i, link))\n    }\n    links = await Promise.all(tasks)\n    console.log('links==========', links.length);\n\n    for (var i = 0; i < links.length; i++) {\n        let item = links[i];\n        let index = item.split('___')[0];\n        let src = item.split('___')[1];\n        downloadTask.push(downloadImg(src, dir, index + links[i].substr(-4, 4)));\n    }\n    await Promise.all(downloadTask);\n}\n\nasync function downloadImg(url, dir, filename) {\n    console.log('download begin---', url);\n    request.get(url).pipe(fs.createWriteStream(dir + \"/\" + filename)).on('close', function() {\n        console.log('download success', url);\n    });\n}\nasync function getResLink(index, url) {\n    const body = await request(url);\n    let urls = [];\n    var $ = cheerio.load(body);\n    $(config.rule).each(function() {\n        var src = $(this).attr('src');\n        urls.push(src);\n    });\n    return index + '___' + urls[0];\n}\n```\n## 基础配置\n由于爬虫的复杂性基于不同的网站，不同的任务很不一样，这里只是把几个常用的变量抽取到了config.js。\n```js\nmodule.exports = {\n    //初始url\n    url: 'http://www.xieet.com/meinv/230',\n    size: 10,\n    // 选中图片img标签的选择器\n    rule: '.imgbox a img'\n};\n```\n\n## 运行代码\n1. 下载我上传的代码[koa-spider](https://github.com/maochunguang/koa-spider)\n2. npm install,npm start即可运行\n\n## 总结\n其实无论是写爬虫还是些其他程序，使用nodejs很大一部分都是要处理异步，要学好nodejs必须学好异步处理。\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["nodejs"],"categories":["学习笔记"]},{"title":"微信公众号开发","url":"/wechat-dev.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n微信公众号开发的一些注意事项\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 开发环境搭建\n1. 微信公众号开发者配置，url，token，\n2. 本地调试，使用内网穿透工具，花生壳，或者netapp，买一个可以自定义域名的，内网映射到制定端口，\n3. 项目搭建，express或koa搭建项目，npm有微信的现成包，直接配置\n\n## 回复\n1. 回复和发消息并没有什么特别注意的地方，这里不多说\n\n## 菜单\n1. 微信菜单有自定义菜单，有个性化菜单，但是个性化菜单优先级高于个性化菜单\n2. 个性化菜单可以根据用户的tag，sex，group等属性进行区分菜单\n3. 注意，我在使用时发现**个性化菜单经常会失效**，不起作用，偶尔会起作用，如果线上打算使用个性化菜单，请慎重并仔细测试\n\n## 授权\n授权有网页授权，js sdk授权，\n网页授权也有两种，一个上静默授权，一个是点击授权，贴一下js sdk调用前认证的代码，要使用sha1加密\n```js\nasync getSignConfig(originUrl) {\n      let data = {}\n      const sha1 = crypto.createHash('sha1')\n      const appId = this.app.config.weixin.appID\n      const jsapi_ticket = await this.ctx.service.token.getJSApiTicket()\n      const noncestr = this.app.config.jsapi.noncestr\n      const url = this.app.config.domain + originUrl\n      const timestamp = parseInt(new Date().getTime() / 1000)\n      // sha1加密\n      const str = `jsapi_ticket=${jsapi_ticket}&noncestr=${noncestr}&timestamp=${timestamp}&url=${url}`\n      sha1.update(str)\n      const signature = sha1.digest('hex')\n      data = { jsapi_ticket, noncestr, timestamp, url, signature, appId }\n      return data\n    }\n```\n调用js sdk页面上代码\n```js\nwx.config({\n    debug: false, // 开启调试模式,\n    appId: appId, // 必填，公众号的唯一标识\n    timestamp: timestamp, // 必填，生成签名的时间戳\n    nonceStr: nonceStr, // 必填，生成签名的随机串\n    signature:  signature,// 必填，签名，见附录1\n    jsApiList: ['closeWindow'] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2\n});\nwx.ready(function(){\n    setTimeout(function(){\n      wx.closeWindow();\n    },2000);\n});\n```\n\n\n## 实用的常识\n1. tag不能重复创建，但是给用户可以重复打同一个tag\n2. 更改菜单一般五分钟生效，或者重新关注公众号，立马能看到\n3. 如果调用js sdk，务必使用https，防止因为安全问题，导致ios下js下载失败。如果你的服务是https，而引用了https的微信js，在ios下肯定会下载失败，这是ios的安全机制导致的。\n4. 微信关闭窗口的js接口，不管jsconfig验证是否通过，窗口都可以关闭\n5. 微信的token过期时间上2h，但是很多时候30分钟不到可能已经失效，建议**把token过期时间设置为10分钟之内**\n\n## 常见报错\n1. 创建菜单的时候，菜单长度不合法，仔细检查自己传的json菜单，一般都是**json格式问题**，而不是长度\n2. redirect_uri不合法，是创建授权菜单的redirect_uri和**网页授权域名**配置不一样\n3. 关注公众号，服务端设置的欢迎消息发不过去，如果自己代码无异常，一般是因为**token过期**\n\n## 以后遇到其他问题继续补充\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["编程语言"],"categories":["javacript"]},{"title":"那些年读的书","url":"/mybooks.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n人生漫漫，不知不觉读了好多书，此贴只记录自己读过哪些书，不做多余的分析和总结。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 读过哪些种类的\n- 编程专业类\n- 小说类\n- 励志类\n\n## 小说\n- 平凡的世界\n- 白鹿原\n- 穆斯林的葬礼\n- 金庸武侠系列\n- 古龙武侠小说\n- 梁羽生武侠小说\n- 余华作品集\n- 雷米小说全集（侦探类）\n\n- 网络小说：\n    - 诛仙，\n    - 盗墓笔记，\n    - 泡沫之夏，\n    - 芈月传，\n\n\n## 编程类\n- java编程思想\n- effective java\n- java并发编程的艺术\n- 代码整洁之道\n- 黑客与画家\n\n- 深入浅出nodejs\n- nodejs实战\n- js高级程序设计\n- survivejs\n- redux和react中文手册\n- 你不知道的javascript\n- 算法javascript实现\n\n- mysql权威指南\n- mongodb权威指南\n- mongodb实战第二版\n- redis入门\n\n## 经管励志\n- 时间管理\n- 一分钟系列\n- 番茄工作法图解\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["学习笔记"],"categories":["book"]},{"title":"免费的开源书籍","url":"/free-books.html","content":"** 免费的开源书籍：** <Excerpt in index | 首页摘要>\n国外程序员在 stackoverflow 推荐的程序员必读书籍，中文版。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 目录\n\n* [语言无关](#语言无关)\n  * [IDE](#ide)\n  * [MySQL](#mysql)\n  * [NoSQL](#nosql)\n  * [PostgreSQL](#postgresql)\n  * [Web](#web)\n  * [WEB服务器](#web服务器)\n  * [其它](#其它)\n  * [函数式概念](#函数式概念)\n  * [分布式系统](#分布式系统)\n  * [在线教育](#在线教育)\n  * [大数据](#大数据)\n  * [操作系统](#操作系统)\n  * [数据库](#数据库)\n  * [智能系统](#智能系统)\n  * [正则表达式](#正则表达式)\n  * [版本控制](#版本控制)\n  * [程序员杂谈](#程序员杂谈)\n  * [管理和监控](#管理和监控)\n  * [编程艺术](#编程艺术)\n  * [编译原理](#编译原理)\n  * [编辑器](#编辑器)\n  * [计算机图形学](#计算机图形学)\n  * [设计模式](#设计模式)\n  * [软件开发方法](#软件开发方法)\n  * [项目相关](#项目相关)\n* [语言相关](#语言相关)\n  * [Android](#android)\n  * [AWK](#awk)\n  * [C](#c)\n  * [C#](#c-sharp)\n  * [C++](#c-1)\n  * [CoffeeScript](#coffeescript)\n  * [Dart](#dart)\n  * [Elasticsearch](#elasticsearch)\n  * [Elixir](#elixir)\n  * [Erlang](#erlang)\n  * [Fortran](#fortran)\n  * [Golang](#golang)\n  * [Haskell](#haskell)\n  * [HTML / CSS](#html--css)\n  * [HTTP](#http)\n  * [iOS](#ios)\n  * [Java](#java)\n  * [JavaScript](#javascript)\n  * [LaTeX](#latex)\n  * [LISP](#lisp)\n  * [Lua](#lua)\n  * [Markdown](#markdown)\n  * [Node.js](#nodejs)\n  * [Perl](#perl)\n  * [PHP](#php)\n  * [Python](#python)\n  * [R](#r)\n  * [reStructuredText](#restructuredtext)\n  * [Ruby](#ruby)\n  * [Rust](#rust)\n  * [Scala](#scala)\n  * [Scheme](#scheme)\n  * [Shell](#shell)\n  * [Swift](#swift)\n  * [Vim](#vim)\n  * [Visual Prolog](#visual-prolog)\n\n\n## 语言无关\n\n## IDE\n\n* [IntelliJ IDEA 简体中文专题教程](https://github.com/judasn/IntelliJ-IDEA-Tutorial)\n\n\n## MySQL\n\n* [21分钟MySQL入门教程](http://www.cnblogs.com/mr-wid/archive/2013/05/09/3068229.html)\n* [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)\n\n\n## NoSQL\n\n* [Disque 使用教程](http://disquebook.com)\n* [Neo4j .rb 中文資源](http://neo4j.tw)\n* [Neo4j 简体中文手册 v1.8](http://docs.neo4j.org.cn)\n* [Redis 命令参考](http://redisdoc.com)\n* [Redis 设计与实现](http://redisbook.com)\n* [The Little MongoDB Book](https://github.com/justinyhuang/the-little-mongodb-book-cn/blob/master/mongodb.md)\n* [The Little Redis Book](https://github.com/JasonLai256/the-little-redis-book/blob/master/cn/redis.md)\n* [带有详细注释的 Redis 2.6 代码](https://github.com/huangz1990/annotated_redis_source)\n* [带有详细注释的 Redis 3.0 代码](https://github.com/huangz1990/redis-3.0-annotated)\n\n\n## PostgreSQL\n\n* [PostgreSQL 8.2.3 中文文档](http://works.jinbuguo.com/postgresql/menu823/index.html)\n* [PostgreSQL 9.3.1 中文文档](http://www.postgres.cn/docs/9.3/index.html)\n\n\n## Web\n\n* [3 Web Designs in 3 Weeks](https://www.gitbook.com/book/juntao/3-web-designs-in-3-weeks/details)\n* [Chrome 开发者工具中文手册](https://github.com/CN-Chrome-DevTools/CN-Chrome-DevTools)\n* [Chrome扩展开发文档](http://open.chrome.360.cn/extension_dev/overview.html)\n* [Growth: 全栈增长工程师指南](https://github.com/phodal/growth-ebook)\n* [Grunt中文文档](http://www.gruntjs.net)\n* [Gulp 入门指南](https://github.com/nimojs/gulp-book)\n* [gulp中文文档](http://www.gulpjs.com.cn/docs/)\n* [HTTP 接口设计指北](https://github.com/bolasblack/http-api-guide)\n* [HTTP/2.0 中文翻译](http://yuedu.baidu.com/ebook/478d1a62376baf1ffc4fad99?pn=1)\n* [http2讲解](https://www.gitbook.com/book/ye11ow/http2-explained/details)\n* [JSON风格指南](https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md)\n* [Wireshark用户手册](http://man.lupaworld.com/content/network/wireshark/index.html)\n* [一站式学习Wireshark](https://community.emc.com/thread/194901)\n* [关于浏览器和网络的 20 项须知](http://www.20thingsilearned.com/zh-CN/home)\n* [前端代码规范 及 最佳实践](http://coderlmn.github.io/code-standards/)\n* [前端开发体系建设日记](https://github.com/fouber/blog/issues/2)\n* [前端资源分享（一）](https://github.com/hacke2/hacke2.github.io/issues/1)\n* [前端资源分享（二）](https://github.com/hacke2/hacke2.github.io/issues/3)\n* [正则表达式30分钟入门教程](http://deerchao.net/tutorials/regex/regex.htm)\n* [浏览器开发工具的秘密](http://jinlong.github.io/2013/08/29/devtoolsecrets/)\n* [移动Web前端知识库](https://github.com/AlloyTeam/Mars)\n* [移动前端开发收藏夹](https://github.com/hoosin/mobile-web-favorites)\n\n\n## WEB服务器\n\n* [Apache 中文手册](http://works.jinbuguo.com/apache/menu22/index.html)\n* [Nginx开发从入门到精通](http://tengine.taobao.org/book/index.html) (淘宝团队出品)\n* [Nginx教程从入门到精通](http://www.ttlsa.com/nginx/nginx-stu-pdf/) (PDF版本，运维生存时间出品)\n\n\n## 其它\n\n* [OpenWrt智能、自动、透明翻墙路由器教程](https://softwaredownload.gitbooks.io/openwrt-fanqiang/content/)\n* [SAN 管理入门系列](https://community.emc.com/docs/DOC-16067)\n* [Sketch 中文手册](http://sketchcn.com/sketch-chinese-user-manual.html#introduce)\n* [深入理解并行编程](http://ifeve.com/perfbook/)\n\n\n## 函数式概念\n\n* [傻瓜函数编程](https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn)\n\n\n## 分布式系统\n\n* [走向分布式](http://dcaoyuan.github.io/papers/pdfs/Scalability.pdf) (PDF)\n\n\n## 在线教育\n\n* [51CTO学院](http://edu.51cto.com)\n* [Codecademy](https://www.codecademy.com/?locale_code=zh)\n* [CodeSchool](https://www.codeschool.com)\n* [Coursera](https://www.coursera.org/courses?orderby=upcoming&lngs=zh)\n* [Learn X in Y minutes](https://learnxinyminutes.com) (数十种语言快速入门教程)\n* [shiyanlou](https://www.shiyanlou.com)\n* [TeamTreeHouse](https://teamtreehouse.com)\n* [Udacity](https://www.udacity.com)\n* [xuetangX](https://www.xuetangx.com)\n* [慕课网](http://www.imooc.com/course/list) (丰富的移动端开发、php开发、web前端、html5教程以及css3视频教程等课程资源)\n* [极客学院](http://www.jikexueyuan.com)\n* [计蒜客](http://www.jisuanke.com)\n\n\n## 大数据\n\n* [Spark 编程指南简体中文版](https://aiyanbo.gitbooks.io/spark-programming-guide-zh-cn/content/)\n* [大型集群上的快速和通用数据处理架构](https://code.csdn.net/CODE_Translation/spark_matei_phd)\n* [大数据/数据挖掘/推荐系统/机器学习相关资源](https://github.com/Flowerowl/Big-Data-Resources)\n* [数据挖掘中经典的算法实现和详细的注释](https://github.com/linyiqun/DataMiningAlgorithm)\n* [面向程序员的数据挖掘指南](http://dataminingguide.books.yourtion.com)\n\n\n## 操作系统\n\n* [Debian 参考手册 ](http://man.chinaunix.net/linux/debian/reference/reference.zh-cn.html)\n* [Docker —— 从入门到实践](https://github.com/yeasy/docker_practice)\n* [Docker中文指南](https://github.com/widuu/chinese_docker)\n* [Docker入门实战](http://yuedu.baidu.com/ebook/d817967416fc700abb68fca1)\n* [FreeBSD 使用手册](http://www.freebsd.org/doc/zh_CN.UTF-8/books/handbook/)\n* [FreeRADIUS新手入门](http://freeradius.akagi201.org)\n* [Linux Documentation (中文版)](https://tinylab.gitbooks.io/linux-doc/content/zh-cn/)\n* [Linux Guide for Complete Beginners](http://happypeter.github.io/LGCB/book/)\n* [Linux 构建指南](http://works.jinbuguo.com/lfs/lfs62/index.html)\n* [Linux 系统高级编程](http://sourceforge.net/projects/elpi/)\n* [Linux工具快速教程](https://github.com/me115/linuxtools_rst)\n* [Mac 开发配置手册](https://aaaaaashu.gitbooks.io/mac-dev-setup/content/)\n* [Operating Systems: Three Easy Pieces](http://pages.cs.wisc.edu/~remzi/OSTEP/)\n* [The Linux Command Line](http://billie66.github.io/TLCL/index.html) (中英文版)\n* [Ubuntu 参考手册 ](http://wiki.ubuntu.org.cn/UbuntuManual)\n* [uCore Lab: Operating System Course in Tsinghua University](https://www.gitbook.com/book/objectkuan/ucore-docs/details)\n* [UNIX TOOLBOX](http://cb.vu/unixtoolbox_zh_CN.xhtml)\n* [命令行的艺术](https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md)\n* [嵌入式 Linux 知识库 (eLinux.org 中文版)](https://tinylab.gitbooks.io/elinux/content/zh/)\n* [开源世界旅行手册](http://i.linuxtoy.org/docs/guide/index.html)\n* [深入分析Linux内核源码](http://www.kerneltravel.net/kernel-book/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81.html)\n* [理解Linux进程](https://github.com/tobegit3hub/understand_linux_process)\n* [鸟哥的 Linux 私房菜 基础学习篇](http://vbird.dic.ksu.edu.tw/linux_basic/linux_basic.php)\n* [鸟哥的 Linux 私房菜 服务器架设篇](http://vbird.dic.ksu.edu.tw/linux_server/)\n\n\n## 数据库\n\n* [Redis 设计与实现](http://redisbook.com)\n* [The Little MongoDB Book 中文版](https://github.com/justinyhuang/the-little-mongodb-book-cn)\n\n\n## 智能系统\n\n* [一步步搭建物联网系统](https://github.com/phodal/designiot)\n\n\n## 正则表达式\n\n* [正则表达式30分钟入门教程](http://deerchao.net/tutorials/regex/regex.htm)\n\n\n## 版本控制\n\n* [Git - 简易指南](http://rogerdudler.github.io/git-guide/index.zh.html)\n* [Git-Cheat-Sheet](https://github.com/flyhigher139/Git-Cheat-Sheet) （感谢 @flyhigher139 翻译了中文版）\n* [Git Community Book 中文版](http://gitbook.liuhui998.com)\n* [git-flow 备忘清单](http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html)\n* [Git magic](http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/)\n* [Git Magic](http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/)\n* [Git 参考手册](http://gitref.justjavac.com)\n* [Github帮助文档](https://github.com/waylau/github-help)\n* [GitHub秘籍](https://snowdream86.gitbooks.io/github-cheat-sheet/content/zh/)\n* [Git教程](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000) （本文由 [@廖雪峰](http://weibo.com/liaoxuefeng) 创作，如果觉得本教程对您有帮助，可以去 [iTunes](https://itunes.apple.com/cn/app/git-jiao-cheng/id876420437) 购买）\n* [Got GitHub](https://github.com/gotgit/gotgithub)\n* [GotGitHub](http://www.worldhello.net/gotgithub/index.html)\n* [HgInit (中文版)](http://bucunzai.net/hginit/)\n* [Mercurial 使用教程](https://www.mercurial-scm.org/wiki/ChineseTutorial)\n* [Pro Git](https://git-scm.com/book/zh/v2)\n* [Pro Git 中文版](https://www.gitbook.com/book/0532/progit/details) (整理在gitbook上)\n* [svn 手册](http://svnbook.red-bean.com/nightly/zh/index.html)\n* [学习 Git 分支](http://pcottle.github.io/learnGitBranching/) (点击右下角按钮可切换至简体及正体中文)\n* [沉浸式学 Git](http://igit.linuxtoy.org/index.html)\n* [猴子都能懂的GIT入门](http://backlogtool.com/git-guide/cn/)\n\n\n## 程序员杂谈\n\n* [程序员的自我修养](http://www.kancloud.cn/kancloud/a-programmer-prepares)\n\n\n## 管理和监控\n\n* [ElasticSearch 权威指南](https://www.gitbook.com/book/fuxiaopang/learnelasticsearch/details)\n* [Elasticsearch 权威指南（中文版）](http://es.xiaoleilu.com)\n* [ELKstack 中文指南](http://kibana.logstash.es)\n* [Logstash 最佳实践](https://github.com/chenryn/logstash-best-practice-cn)\n* [Mastering Elasticsearch(中文版)](http://udn.yyuap.com/doc/mastering-elasticsearch/)\n* [Puppet 2.7 Cookbook 中文版](http://bbs.konotes.org/workdoc/puppet-27/)\n\n\n## 编程艺术\n\n* [取悦的工序：如何理解游戏](http://read.douban.com/ebook/4972883/) (豆瓣阅读，免费书籍)\n* [每个程序员都应该了解的内存知识(译)](http://www.oschina.net/translate/what-every-programmer-should-know-about-memory-part1?print)【第一部分】\n* [程序员编程艺术](https://github.com/julycoding/The-Art-Of-Programming-by-July)\n* [编程入门指南](http://www.kancloud.cn/kancloud/intro-to-prog/52592)\n\n\n## 编译原理\n\n* [《计算机程序的结构和解释》公开课 翻译项目](https://github.com/DeathKing/Learning-SICP)\n\n\n## 编辑器\n\n* [exvim--vim 改良成IDE项目](http://exvim.github.io/docs-zh/intro/)\n* [Vim中文文档](https://github.com/vimcn/vimcdoc)\n* [所需即所获：像 IDE 一样使用 vim](https://github.com/yangyangwithgnu/use_vim_as_ide)\n* [笨方法学Vimscript 中译本](http://learnvimscriptthehardway.onefloweroneworld.com)\n\n\n## 计算机图形学\n\n* [OpenGL 教程](https://github.com/zilongshanren/opengl-tutorials)\n\n\n## 设计模式\n\n* [史上最全设计模式导学目录](http://blog.csdn.net/lovelion/article/details/17517213)\n* [图说设计模式](https://github.com/me115/design_patterns)\n\n\n## 软件开发方法\n\n* [傻瓜函数编程](https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn) (《Functional Programming For The Rest of Us》中文版)\n* [硝烟中的 Scrum 和 XP](http://www.infoq.com/cn/minibooks/scrum-xp-from-the-trenches)\n\n\n## 项目相关\n\n* [GNU make 指南](http://docs.huihoo.com/gnu/linux/gmake.html)\n* [Gradle 2 用户指南](https://github.com/waylau/Gradle-2-User-Guide)\n* [Gradle 中文使用文档](http://yuedu.baidu.com/ebook/f23af265998fcc22bcd10da2)\n* [Joel谈软件](http://local.joelonsoftware.com/wiki/Chinese_(Simplified))\n* [selenium 中文文档](https://github.com/fool2fish/selenium-doc)\n* [开源软件架构](http://www.ituring.com.cn/book/1143)\n* [持续集成（第二版）](http://article.yeeyan.org/view/2251/94882) (译言网)\n* [約耳談軟體(Joel on Software)](http://local.joelonsoftware.com/wiki/%E9%A6%96%E9%A0%81)\n* [编码规范](https://github.com/ecomfe/spec)\n* [让开发自动化系列专栏](http://www.ibm.com/developerworks/cn/java/j-ap/)\n* [追求代码质量](http://www.ibm.com/developerworks/cn/java/j-cq/)\n\n\n## 语言相关\n\n## Android\n\n* [Android Design(中文版)](http://www.apkbus.com/design/index.html)\n* [Android Note(开发过程中积累的知识点)](https://github.com/CharonChui/AndroidNote)\n* [Android6.0新特性详解](http://leanote.com/blog/post/561658f938f41126b2000298?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)\n* [Android学习之路](http://stormzhang.github.io/android/2014/07/07/learn-android-from-rookie/)\n* [Android开发技术前线(android-tech-frontier)](https://github.com/bboyfeiyu/android-tech-frontier)\n* [Google Android官方培训课程中文版](http://hukai.me/android-training-course-in-chinese/index.html)\n* Google Material Design 正體中文版 ([译本一](https://wcc723.gitbooks.io/google_design_translate/content/style-icons.html) [译本二](https://github.com/1sters/material_design_zh))\n* [Material Design 中文版](http://wiki.jikexueyuan.com/project/material-design/)\n* [Point-of-Android](https://github.com/FX-Max/Point-of-Android) Android 一些重要知识点解析整理\n\n\n## AWK\n\n* [awk中文指南](http://awk.readthedocs.org/en/latest/index.html)\n* [awk程序设计语言](https://github.com/wuzhouhui/awk)\n\n\n## C\n\n* [C 语言常见问题集](http://c-faq-chn.sourceforge.net/ccfaq/ccfaq.html)\n* [C/C++ 学习教程](http://doc.lellansin.com)\n* [Linux C 编程一站式学习](http://docs.linuxtone.org/ebooks/C&CPP/c/)\n* [新概念 C 语言教程](https://github.com/limingth/NCCL)\n\n\n## C Sharp\n\n* [精通C#(第6版) ](http://book.douban.com/subject/24827879/)\n\n\n## C++\n\n* [100个gcc小技巧](https://github.com/hellogcc/100-gcc-tips/blob/master/src/index.md)\n* [100个gdb小技巧](https://github.com/hellogcc/100-gdb-tips/blob/master/src/index.md)\n* [C 语言编程透视](https://tinylab.gitbooks.io/cbook/content/)\n* [C/C++ Primer](https://github.com/andycai/cprimer) - @andycai\n* [C++ FAQ LITE(中文版)](http://www.sunistudio.com/cppfaq/)\n* [C++ Primer 5th Answers](https://github.com/Mooophy/Cpp-Primer)\n* [C++ Template 进阶指南](https://github.com/wuye9036/CppTemplateTutorial)\n* [C++ 基础教程](http://www.prglab.com/cms/)\n* [C++ 并发编程(基于C++11)](https://chenxiaowei.gitbooks.io/cpp_concurrency_in_action/content/)\n* [C++ 并发编程指南](https://github.com/forhappy/Cplusplus-Concurrency-In-Practice)\n* [CGDB中文手册](https://github.com/leeyiw/cgdb-manual-in-chinese)\n* [Cmake 实践](http://sewm.pku.edu.cn/src/paradise/reference/CMake%20Practice.pdf) (PDF版)\n* [GNU make 指南](http://docs.huihoo.com/gnu/linux/gmake.html)\n* [Google C++ 风格指南](http://zh-google-styleguide.readthedocs.org/en/latest/google-cpp-styleguide/contents/)\n* [QT 教程](http://www.kuqin.com/qtdocument/tutorial.html)\n* [ZMQ 指南](https://github.com/anjuke/zguide-cn)\n* [像计算机科学家一样思考（C++版)](http://www.ituring.com.cn/book/1203) (《How To Think Like a Computer Scientist: C++ Version》中文版)\n* [简单易懂的C魔法](http://www.nowamagic.net/librarys/books/contents/c)\n* [跟我一起写Makefile(PDF)](http://scc.qibebt.cas.cn/docs/linux/base/%B8%FA%CE%D2%D2%BB%C6%F0%D0%B4Makefile-%B3%C2%F0%A9.pdf) (PDF)\n\n\n## CoffeeScript\n\n* [CoffeeScript 中文](http://coffee-script.org)\n* [CoffeeScript 编程风格指南](https://github.com/elrrrrrrr/coffeescript-style-guide/blob/master/README-ZH.md)\n\n\n## Dart\n\n* [Dart 语言导览](http://dart.lidian.info/wiki/Language_Tour)\n\n\n## Elasticsearch\n\n* [Elasticsearch 权威指南](https://github.com/looly/elasticsearch-definitive-guide-cn) （《Elasticsearch the definitive guide》中文版）\n* [ELKstack 中文指南](http://kibana.logstash.es)\n* [Mastering Elasticsearch(中文版)](http://udn.yyuap.com/doc/mastering-elasticsearch/)\n\n\n## Elixir\n\n* [Elixir Getting Started 中文翻译](https://github.com/Ljzn/ElixrGettingStartedChinese)\n* [Elixir 编程语言教程](https://elixirschool.com/cn/) (Elixir School)\n* [Elixir元编程与DSL 中文翻译](https://github.com/Ljzn/MetaProgrammingInElixirChinese)\n* [Phoenix 框架中文文档](https://mydearxym.gitbooks.io/phoenix-doc-in-chinese/content/)\n\n\n## Erlang\n\n* [Erlang 并发编程](https://github.com/liancheng/cpie-cn) (《Concurrent Programming in Erlang (Part I)》中文版)\n\n\n## Fortran\n\n* [Fortran77和90/95编程入门](http://micro.ustc.edu.cn/Fortran/ZJDing/)\n\n\n## Golang\n\n* [Effective Go](http://www.hellogcc.org/effective_go.html)\n* [Go Web 编程](https://github.com/astaxie/build-web-application-with-golang)\n* [Go 入门指南](https://github.com/Unknwon/the-way-to-go_ZH_CN) (《The Way to Go》中文版)\n* [Go 官方文档翻译](https://github.com/golang-china/golangdoc.translations)\n* [Go 指南](http://go-tour-zh.appsp0t.com) (《A Tour of Go》中文版)\n* [Go 简易教程](https://github.com/songleo/the-little-go-book_ZH_CN) (《[The Little Go Book](https://github.com/karlseguin/the-little-go-book)》中文版)\n* [Go 编程基础](https://github.com/Unknwon/go-fundamental-programming)\n* [Go 语言标准库](https://github.com/polaris1119/The-Golang-Standard-Library-by-Example)\n* [Go命令教程](https://github.com/hyper-carrot/go_command_tutorial)\n* [Go实战开发](https://github.com/astaxie/Go-in-Action)\n* [Go语言博客实践](https://github.com/achun/Go-Blog-In-Action)\n* [Java程序员的Golang入门指南](http://blog.csdn.net/dc_726/article/details/46565241)\n* [Network programming with Go 中文翻译版本](https://github.com/astaxie/NPWG_zh)\n* [Revel 框架手册](http://gorevel.cn/docs/manual/index.html)\n* [学习Go语言](http://mikespook.com/learning-go/)\n\n\n## Groovy\n\n* [实战 Groovy 系列](http://www.ibm.com/developerworks/cn/java/j-pg/)\n\n\n## Haskell\n\n* [Haskell 趣学指南](http://learnyoua.haskell.sg)\n* [Real World Haskell 中文版](http://cnhaskell.com)\n\n\n## HTML / CSS\n\n* [CSS3 Tutorial 《CSS3 教程》](https://github.com/waylau/css3-tutorial)\n* [CSS参考手册](http://css.doyoe.com)\n* [Emmet 文档](http://yanxyz.github.io/emmet-docs/)\n* [HTML5 教程](http://www.w3school.com.cn/html5/)\n* [HTML和CSS编码规范](http://codeguide.bootcss.com)\n* [Sass Guidelines 中文](http://sass-guidelin.es/zh/)\n* [前端代码规范](http://alloyteam.github.io/CodeGuide/) (腾讯 AlloyTeam 团队)\n* [学习CSS布局](http://zh.learnlayout.com)\n* [通用 CSS 笔记、建议与指导](https://github.com/chadluo/CSS-Guidelines/blob/master/README.md)\n\n\n## iOS\n\n* [Apple Watch开发初探](http://nilsun.github.io/apple-watch/)\n* [Google Objective-C Style Guide 中文版](http://zh-google-styleguide.readthedocs.org/en/latest/google-objc-styleguide/)\n* [iOS7人机界面指南](http://isux.tencent.com/ios-human-interface-guidelines-ui-design-basics-ios7.html)\n* [iOS开发60分钟入门](https://github.com/qinjx/30min_guides/blob/master/ios.md)\n* [iPhone 6 屏幕揭秘](http://wileam.com/iphone-6-screen-cn/)\n* [网易斯坦福大学公开课：iOS 7应用开发字幕文件](https://github.com/jkyin/Subtitle)\n\n\n## Java\n\n* [Activiti 5.x 用户指南](https://github.com/waylau/activiti-5.x-user-guide)\n* [Apache MINA 2 用户指南](https://github.com/waylau/apache-mina-2.x-user-guide)\n* [Apache Shiro 用户指南](https://github.com/waylau/apache-shiro-1.2.x-reference)\n* [Google Java编程风格指南](http://www.hawstein.com/posts/google-java-style.html)\n* [H2 Database 教程](https://github.com/waylau/h2-database-doc)\n* [Java Servlet 3.1 规范](https://github.com/waylau/servlet-3.1-specification)\n* [Java 编码规范](https://github.com/waylau/java-code-conventions)\n* [Jersey 2.x 用户指南](https://github.com/waylau/Jersey-2.x-User-Guide)\n* [JSSE 参考指南](https://github.com/waylau/jsse-reference-guide)\n* [MyBatis中文文档](http://mybatis.github.io/mybatis-3/zh/index.html)\n* [Netty 4.x 用户指南](https://github.com/waylau/netty-4-user-guide)\n* [Netty 实战(精髓)](https://github.com/waylau/essential-netty-in-action)\n* [REST 实战](https://github.com/waylau/rest-in-action)\n* [Spring Boot参考指南](https://github.com/qibaoguang/Spring-Boot-Reference-Guide) (翻译中)\n* [Spring Framework 4.x参考文档](https://github.com/waylau/spring-framework-4-reference)\n* [用jersey构建REST服务](https://github.com/waylau/RestDemo)\n\n\n## Javascript\n\n* [Airbnb JavaScript 规范](https://github.com/adamlu/javascript-style-guide)\n* AngularJS\n  * [AngularJS中译本](https://github.com/peiransun/angularjs-cn)\n  * [AngularJS入门教程](https://github.com/zensh/AngularjsTutorial_cn)\n  * [AngularJS最佳实践和风格指南](https://github.com/mgechev/angularjs-style-guide/blob/master/README-zh-cn.md)\n  * [在Windows环境下用Yeoman构建AngularJS项目](http://www.waylau.com/build-angularjs-app-with-yeoman-in-windows/)\n  * [构建自己的AngularJS](https://github.com/xufei/Make-Your-Own-AngularJS/blob/master/01.md)\n* backbone.js\n  * [backbone.js中文文档](http://www.css88.com/doc/backbone/)\n  * [backbone.js入门教程](http://www.the5fire.com/backbone-js-tutorials-pdf-download.html) (PDF)\n  * [Backbone.js入门教程第二版](https://github.com/the5fire/backbonejs-learning-note)\n  * [Developing Backbone.js Applications(中文版)](http://feliving.github.io/developing-backbone-applications)\n* [Chrome扩展及应用开发](http://www.ituring.com.cn/minibook/950)\n* CoffeeScript\n  * [CoffeeScript 编码风格指南](https://github.com/geekplux/coffeescript-style-guide)\n* D3.js\n  * [D3.js 入门系列](http://www.ourd3js.com/wordpress/?cat=2) (还有进阶、高级等系列)\n  * [官方API文档](https://github.com/mbostock/d3/wiki/API--%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C)\n  * [张天旭的D3教程](http://blog.csdn.net/zhang__tianxu/article/category/1623437)\n  * [楚狂人的D3教程](http://www.cnblogs.com/winleisure/tag/D3.js/)\n* [ECMAScript 6 入门](http://es6.ruanyifeng.com) (作者：阮一峰)\n* ExtJS\n  * [Ext4.1.0 中文文档](http://extjs-doc-cn.github.io/ext4api/)\n* [Google JavaScript 代码风格指南](http://bq69.com/blog/articles/script/868/google-javascript-style-guide.html)\n* [Google JSON 风格指南](https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md)\n* impress.js\n  * [impress.js的中文教程](https://github.com/kokdemo/impress.js-tutorial-in-Chinese)\n* [JavaScript Promise迷你书](http://liubin.github.io/promises-book/)\n* [Javascript 原理](http://typeof.net/s/jsmech/)\n* [JavaScript 标准参考教程（alpha）](http://javascript.ruanyifeng.com)\n* [《JavaScript 模式》](https://github.com/jayli/javascript-patterns) “JavaScript patterns”中译本\n* [javascript 的 12 个怪癖](https://github.com/justjavac/12-javascript-quirks)\n* [JavaScript 秘密花园](http://bonsaiden.github.io/JavaScript-Garden/zh/)\n* [JavaScript核心概念及实践](http://icodeit.org/jsccp/) (PDF) (此书已由人民邮电出版社出版发行，但作者依然免费提供PDF版本，希望开发者们去购买，支持作者)\n* [Javascript编程指南](http://pij.robinqu.me) ([源码](https://github.com/RobinQu/Programing-In-Javascript))\n* jQuery\n  * [How to write jQuery plugin](http://i5ting.github.io/How-to-write-jQuery-plugin/build/jquery.plugin.html)\n  * [简单易懂的JQuery魔法](http://www.nowamagic.net/librarys/books/contents/jquery)\n* Meteor\n  * [Discover Meteor](http://zh.discovermeteor.com)\n* Node.js\n  * [express.js 中文文档](http://expressjs.jser.us)\n  * [Express框架](http://javascript.ruanyifeng.com/nodejs/express.html)\n  * [koa 中文文档](https://github.com/guo-yu/koa-guide)\n  * [Learn You The Node.js For Much Win! (中文版)](https://www.npmjs.com/package/learnyounode-zh-cn)\n  * [Node debug 三法三例](http://i5ting.github.io/node-debug-tutorial/)\n  * [Node.js Fullstack《從零到一的進撃》](https://github.com/jollen/nodejs-fullstack-lessons)\n  * [Node.js 包教不包会](https://github.com/alsotang/node-lessons)\n  * [Nodejs Wiki Book](https://github.com/nodejs-tw/nodejs-wiki-book) (繁体中文)\n  * [nodejs中文文档](https://www.gitbook.com/book/0532/nodejs/details)\n  * [Node入门](http://www.nodebeginner.org/index-zh-cn.html)\n  * [七天学会NodeJS](http://nqdeng.github.io/7-days-nodejs/)\n  * [使用 Express + MongoDB 搭建多人博客](https://github.com/nswbmw/N-blog)\n* React.js\n  * [Learn React & Webpack by building the Hacker News front page](https://github.com/theJian/build-a-hn-front-page)\n  * [React Native 中文文档(含最新Android内容)](http://wiki.jikexueyuan.com/project/react-native/)\n  * [React webpack-cookbook](https://github.com/fakefish/react-webpack-cookbook)\n  * [React 入门教程](http://fraserxu.me/intro-to-react/)\n  * [React.js 中文文档](http://reactjs.cn)\n* underscore.js\n  * [Underscore.js中文文档](http://learningcn.com/underscore/)\n* [You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS) (深入JavaScript语言核心机制的系列图书)\n* Zepto.js\n  * [Zepto.js 中文文档](http://mweb.baidu.com/zeptoapi/)\n* [命名函数表达式探秘](http://justjavac.com/named-function-expressions-demystified.html)  (注:原文由[为之漫笔](http://www.cn-cuckoo.com) 翻译，原始地址无法打开，所以此处地址为我博客上的备份)\n* [学用 JavaScript 设计模式](http://www.oschina.net/translate/learning-javascript-design-patterns) (开源中国)\n* [深入理解JavaScript系列](http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html)\n\n\n## LaTeX\n\n* [LaTeX 笔记](http://www.dralpha.com/zh/tech/tech.htm)\n* [一份不太简短的 LaTeX2ε 介绍](http://ctan.org/pkg/lshort-zh-cn)\n* [大家來學 LaTeX](https://github.com/49951331/graduate-project-102pj/blob/master/docs/latex123.pdf) (PDF)\n\n\n## LISP\n\n* [ANSI Common Lisp 中文翻译版](http://acl.readthedocs.org/en/latest/)\n* [Common Lisp 高级编程技术](http://www.ituring.com.cn/minibook/862) (《On Lisp》中文版)\n\n\n## Lua\n\n* [Lua 5.3 参考手册](http://www.w3cschool.cc/manual/lua53doc/contents.html)\n\n\n## Markdown\n\n* [Markdown 快速入门](http://wowubuntu.com/markdown/basic.html)\n* [Markdown 简明教程](http://www.jianshu.com/p/7bd23251da0a)\n* [Markdown 语法说明](http://wowubuntu.com/markdown/)\n* [献给写作者的 Markdown 新手指南](http://www.jianshu.com/p/q81RER)\n\n\n## Node.js\n\n* [Node 入门](http://www.nodebeginner.org/index-zh-cn.html)\n* [The NodeJS 中文文档](https://www.gitbook.com/book/0532/nodejs/details)（社区翻译）\n* [七天学会NodeJS](http://nqdeng.github.io/7-days-nodejs/) 阿里出品，很好的入门资料\n\n\n## Perl\n\n* [Master Perl Today](https://github.com/fayland/chinese-perl-book)\n* [《Modern Perl》中文版](https://github.com/horus/modern_perl_book)\n* [Perl 5 教程](http://www.cbi.pku.edu.cn/chinese/documents/perl/index.htm)\n* [Perl 教程](http://www.yiibai.com/perl)\n\n\n## PHP\n\n* [PHP 之道](http://wulijun.github.io/php-the-right-way/)\n* [PHP5中文手册](http://php.net/manual/zh/)\n* [PHP扩展开发及内核应用](http://www.walu.cc/phpbook/preface.md)\n* [Symfony2 实例教程](https://wusuopu.gitbooks.io/symfony2_tutorial/content)\n* [深入理解 PHP 内核](http://www.php-internals.com/book/)\n\n\n## Python\n\n* [Django book 2.0](http://djangobook.py3k.cn/2.0/)\n* [Python 3 文档(简体中文) 3.2.2 documentation](http://docspy3zh.readthedocs.org/en/latest/)\n* [Python 中文学习大本营](http://www.pythondoc.com)\n* [深入 Python 3](https://github.com/jiechic/diveintopython3)\n* [笨办法学 Python](http://old.sebug.net/paper/books/LearnPythonTheHardWay/)\n\n\n## R\n\n* [153分钟学会 R](http://cran.r-project.org/doc/contrib/Liu-FAQ.pdf) (PDF)\n* [《R for beginners》中文版](http://www.biosino.org/R/R-doc/files/R4beg_cn_2.0.pdf) (PDF)\n* [R 导论](http://cran.r-project.org/doc/contrib/Ding-R-intro_cn.pdf) (《An Introduction to R》中文版) (PDF)\n* [用 R 构建 Shiny 应用程序](http://yanping.me/shiny-tutorial/) (《Building 'Shiny' Applications with R》中文版)\n* [统计学与 R 读书笔记](http://cran.r-project.org/doc/contrib/Xu-Statistics_and_R.pdf) (PDF)\n\n\n## reStructuredText\n\n* [reStructuredText 入门](http://www.pythondoc.com/sphinx/rest.html)\n* [reStructuredText 简明教程](http://jwch.sdut.edu.cn/book/rst.html)\n\n\n## Ruby\n\n* [Rails 风格指南](https://github.com/JuanitoFatas/rails-style-guide/blob/master/README-zhCN.md)\n* [Ruby on Rails Tutorial 原书第 2 版](http://railstutorial-china.org)\n* [Ruby on Rails 实战圣经](https://ihower.tw/rails4/)\n* [Ruby 风格指南](https://github.com/JuanitoFatas/ruby-style-guide/blob/master/README-zhCN.md)\n* [笨方法学 Ruby](http://lrthw.github.io)\n\n\n## Rust\n\n* [Rust 官方教程](https://github.com/KaiserY/rust-book-chinese)\n* [Rust 语言学习笔记](https://github.com/photino/rust-notes)\n* [RustPrimer](https://github.com/rustcc/RustPrimer)\n* [通过例子学习 Rust](https://github.com/rustcc/rust-by-example/)\n\n\n## Scala\n\n* [Effective Scala](http://twitter.github.io/effectivescala/index-cn.html)\n* [Scala 初学者指南](https://www.gitbook.com/book/windor/beginners-guide-to-scala/details) (The Neophyte's Guide to Scala)\n* [Scala 课堂](http://twitter.github.io/scala_school/zh_cn/index.html) (Twitter的Scala中文教程)\n\n\n## Scheme\n\n* [Scheme 入门教程](http://deathking.github.io/yast-cn/) (《Yet Another Scheme Tutorial》中文版)\n\n\n## Shell\n\n* [Shell 编程基础](http://wiki.ubuntu.org.cn/Shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)\n* [Shell 脚本编程30分钟入门](https://github.com/qinjx/30min_guides/blob/master/shell.md)\n* [The Linux Command Line 中文版](http://billie66.github.io/TLCL/book/zh)\n\n\n## Swift\n\n* [《The Swift Programming Language》中文版](https://www.gitbook.com/book/numbbbbb/-the-swift-programming-language-/details)\n\n\n## Vim\n\n* [Vim Manual(中文版)](http://man.chinaunix.net/newsoft/vi/doc/help.html)\n* [大家來學 VIM](http://www.study-area.org/tips/vim/index.html)\n\n\n## Visual Prolog\n\n* [Visual Prolog 7初学指南](http://wiki.visual-prolog.com/index.php?title=A_Beginners_Guide_to_Visual_Prolog_in_Chinese)\n* [Visual Prolog 7边练边学](http://wiki.visual-prolog.com/index.php?title=Visual_Prolog_for_Tyros_in_Chinese)\n\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["book"],"categories":["资源分享"]},{"title":"Hexo配置和优化记录","url":"/hexo-config.html","content":"** hexo配置和优化高级篇：** <Excerpt in index | 首页摘要>\n本文章不讲解hexo的基础配置，只针对hexo的高级配置，性能优化，seo配置进行讲解。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 前言\n仔细想想，使用hexo搭建博客也有半年多了，但是发现访问量一直几乎没有，特别是经历几次迁移之后，之前从github到coding，\n现在迁移到了云服务器，研究了一下如何进行seo和网站性能优化，便有了这篇文章。\n\n## 实用的功能\n1. 站内搜索（百度的）\n2. 本地搜索（本地插件）\n3. 网站统计\n4. 留言功能\n5. rss订阅功能\n\n\n## 性能优化\n1. html压缩\n2. css压缩\n3. js压缩·\n4. img压缩\n5. nginx代理，开启gzip压缩\n6. cdn代理css和图·片\n7. 删除主题无用的js和css\n\n## seo优化\n1. sitemap\n2. 对于没有价值的外链a标签添加`rel=\"external nofollow\"`\n3. 使用meta标签\n4. 使用robots文件\n5. 主动提交sitemap到搜索引擎\n6. 添加外链和内链\n\n\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["hexo"],"categories":["开发工具"]},{"title":"Ubuntu服务器详细配置","url":"/server-config.html","content":"** ubuntu服务器私人定制：** <Excerpt in index | 首页摘要>\n把ubuntu服务器打造成自己的个性服务器，装逼必备！！！\n<!-- more -->\n<The rest of contents | 余下全文>\n\n##　说明\n**此教程针对Ubuntu14,其他版本仅作参考**\n\n##　用户密码管理\n`sudo passwd root`\n1. 添加一个用户组并指定id为1002\n`sudo groupadd －g 1002 www`\n2. 添加一个用户到www组并指定id为1003\n`sudo useradd wyx -g 1002 -u 1003 -m`\n\n3. 修改用户的密码\n`sudo passwd wyx`\n4. 删除一个用户\n`sudo userdel wyx`\n\n5. 为该用户添加sudo权限\n\n```bash\nsudo usermod -a -G adm wyx\nsudo usermod -a -G sudo wyx\n```\n\n6. 查看所有用户和用户组：\n```bash\ncat /etc/passwd\ncat /etc/group\n```\n## 安装nodejs\n1. 安装nvm`curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh | bash`\n2. 安装node`nvm install v4.4.4`,安装`nvm install v6.9.1`\n3. 设置默认的node版本`nvm alias default v4.4.4`\n4. 安装npm3  `npm install -g npm@3`\n5. 设置淘宝的cnpm源  `npm install -g cnpm --registry=https://registry.npm.taobao.org`\n6. 验证安装`node -v,npm -v,cnpm -v`\n## 安装node常用包\n1. 安装pm2`cnpm install -g pm2`\n2. 安装hexo博客`cnpm install -g hexo-cli`\n3. 安装同步插件rsync`cnpm install -g rsync`\n\n## 安装docker\n1. apt安装\n\n```bash\nsudo apt-get update\nsudo apt-get install -y docker.io\nsudo ln -sf /usr/bin/docker.io /usr/local/bin/docker\nsudo sed -i '$acomplete -F _docker docker' /etc/bash_completion.d/docker.io\n```\n\n2. 源码安装最新版本\n\n```bash\nsudo apt-get install apt-transport-https\nsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9\nsudo bash -c \"echo deb https://get.docker.io/ubuntu docker main > /etc/apt/sources.list.d/docker.list\"\nsudo apt-get update\nsudo apt-get install lxc-docker\n```\n\n3. 验证安装版本\n` docker -v`\n\n## 安装nginx\n`sudo apt-get install nginx`\n启动和配置nginx\n## 安装redis\n`sudo apt-get install redis-server`\n启动和配置文件:\n## 安装mongodb\n1. 安装3.0\n\n```bash\napt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10\necho \"deb http://repo.mongodb.org/apt/debian wheezy/mongodb-org/3.0 main\" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.0.list\napt-get update  \napt-get install mongodb-org\n```\n\n2. 安装3.2最新版\n\n```bash\nsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv EA312927\necho \"deb http://repo.mongodb.org/apt/ubuntu \"$(lsb_release -sc)\"/mongodb-org/3.2 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb.list\nsudo apt-get update\nsudo apt-get install mongodb-org\n```\n\n3. 制定版本\n`apt-get install mongodb-org=3.2.0 mongodb-org-server=3.2.0 mongodb-org-shell=3.2.0 mongodb-org-mongos=3.2.0 mongodb-org-tools=3.2.0`\n\n4. 启动服务\n\n```bash\nsudo service mongod start\nsudo service mongod stop\n```\n\n5. 验证安装\n`mongod --version`\n\n配置\n\n## 安装jdk\n安装jdk1.7`sudo apt-get install openjdk-7-jdk`\n源码安装\n\n```bash\nsudo mkdir /usr/lib/jvm\nsudo tar zxvf jdk-7u21-linux-i586.tar.gz -C /usr/lib/jvm\ncd /usr/lib/jvm\nsudo mv jdk1.7.0_21 java\n\nsudo vim ~/.bashrc\n\nexport JAVA_HOME=/usr/lib/jvm/java\nexport JRE_HOME=${JAVA_HOME}/jre  \nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  \nexport PATH=${JAVA_HOME}/bin:$PATH  \n```\n## 安装mysql\n实用ubuntu自带的工具下载\n`sudo apt-get install mysql-server`\n\n## 环境变量\n常见的方法有两种。\n\n1. 在用户主目录下有一个 .bashrc 文件，可以在此文件中加入 PATH 的设置如下： \n`export PATH=”$PATH:/your path1/:/your path2/…..” `\n\n2. 在 /etc/profile中增加\n```bash\nPATH=\"$PATH:/home/zhengb66/bin\" \nexport PATH\n``` \n\n## 开机自启动\n1. 方法一，编辑rc.loacl脚本\nUbuntu开机之后会执行/etc/rc.local文件中的脚本，\n所以我们可以直接在/etc/rc.local中添加启动脚本。\n当然要添加到语句：exit 0 前面才行。代码如下:\n`sudo vi /etc/rc.local`\n然后在 exit 0 前面添加好脚本代码。\n\n2. 方法二，添加一个Ubuntu的开机启动服务。\n如果要添加为开机启动执行的脚本文件，\n可先将脚本复制或者软连接到/etc/init.d/目录下，\n然后用：update-rc.d xxx defaults NN命令(NN为启动顺序)，\n将脚本添加到初始化执行的队列中去。\n注意如果脚本需要用到网络，则NN需设置一个比较大的数字，如99。\n1) 将你的启动脚本复制到 /etc/init.d目录下\n 以下假设你的脚本文件名为 test。\n2) 设置脚本文件的权限\n\n代码如下:\n`sudo chmod 755 /etc/init.d/test`\n3) 执行如下命令将脚本放到启动脚本中去：\n代码如下:\n`cd /etc/init.d`  `sudo update-rc.d test defaults 95`\n 注：其中数字95是脚本启动的顺序号，按照自己的需要相应修改即可。在你有多个启动脚本，而它们之间又有先后启动的依赖关系时你就知道这个数字的具体作用了。该命令的输出信息参考如下：\n卸载启动脚本的方法：\n代码如下:\n`cd /etc/init.d`\n`sudo update-rc.d -f test remove`\n\n## 定时任务\n在Ubuntu下，cron是被默认安装并启动的。通过查看/etc/crontab\n推荐使用crontab -e命令添加自定义的任务（编辑的是/var/spool/cron下对应用户的cron文件，在/var/spool/cron下的crontab文件 不可以直接创建或者直接修改，crontab文件是通过crontab命令得到的）。\n`crontab -e`\n\n1. 直接执行命令行\n每2分钟打印一个字符串“Hello World”，保存至文件/home/laigw/cron/HelloWorld.txt中，cron 格式如下：\n`*/2 * * * * echo “Hello World.” >> /home/HelloWorld.txt`\n\n2. shell 文件\n每3分钟调用一次 /home/laigw/cron/test.sh 文件，cron 格式如下：\n`*/3 * * * * /home/laigw/cron/test.sh`\n## ftp和rsync配置\n\n## 持续集成环境\n1. jenkens配置\n2. gitlab配置\n3. git服务器\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["linux"],"categories":["开发工具"]},{"title":"Mac开发环境配置","url":"/mac-dev.html","content":"** mac开发环境配置：** <Excerpt in index | 首页摘要>\n工欲善其事，必先利其器，做好开发者，先搞好开发环境啊。针对mac开发者的开发配置，把mac打造成最具生产力工具！\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 软件下载说明\n下面所提到的软件，有很多需要付费或者破解版，为了方便大家使用，会在网盘分享给大家，只需在评论的地方留下自己的**百度云账号**！！！\n\n## 软件分类说明\n1. 通用（开发者必备的软件）\n2. java类（java开发者必不可少）\n3. 前端类（偏前端和nodejs）\n4. python类\n5. 数据库类\n6. 其他（php，ruby等等）\n\n## 通用软件\n1. Alfred\n2. dash\n3. homebrew\n4. zsh（oh my zsh）\n5. sublime text3,\n6. vscode\n7. paste(剪切板工具)\n8. BetterSnapTool(分屏软件)\n9. cornerstone(svn)\n10. tower(git)\n11. alternote()\n12. paw\n13. chrome\n14. firefox\n15. pdf expert\n16. CheatSheet\n17. snippetslab\n\n## java软件\n1. jdk\n2. idea\n3. eclipse\n4. maven\n5. zookeeper,dubbo\n6. tomcat\n7. apache\n\n## 前端必备\n1. nvm(nodejs,npm,cnpm)\n2. webpack\n3. yo\n4. webstorm\n\n\n## python必备\n1. pycharm\n2. sublime text（插件）\n\n## 数据库类\n1. mysql\n2. mongodb\n3. sqllite\n4. navicate\n5. robomongo\n6. redis\n\n## 其他软件\n1. office\n2. keynote,pages,number\n3. photoshop\n\n文章长期更新，请收藏\n\n\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["mac"],"categories":["开发工具"]},{"title":"Atom中最好的js代码补全","url":"/best-js-snippet.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n    这或许是atom中最好的js代码补全,包含了express,nodejs,es6,目前仍在继续更新\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## best-js-snippets\n\n这个package的名字就叫 **best-js-snippets** ,用atom的可以下载使用一下,提出建议,我会尽快修改\n![best-js-snippets](http://o7kalf5h3.bkt.clouddn.com/snippets.png)\n\n## 特性\n1. express补全\n2. es6补全\n3. js补全(string,dom操作)\n4. nodejs补全(fs,event,util,module,class,assert)\n\n\n## 如何安装\n1. atom编辑器中找到设置,搜索package,安装即可.\n2. 重启atom,享受吧!\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["others"],"categories":["开发工具"]},{"title":"常用排序算法学习","url":"/sort-study.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n    程序员各种排序算法，算法的实现和分析\n <!-- more -->\n<The rest of contents | 余下全文>\n\n## 排序算法的分类\n1. 排序分内排序和外排序。\n2. 内排序:指在排序期间数据对象全部存放在内存的排序。\n3. 外排序:指在排序期间全部对象个数太多,不能同时存放在内存,必须根据排序过程的要求,不断在内、外存之间移动的排序。\n4. 内排序的方法有许多种,按所用策略不同,可归纳为五类:插入排序、选择排序、交换排序、归并排序、分配排序和计数排序。\n5. 插入排序主要包括直接插入排序，折半插入排序和希尔排序两种;\n6. 选择排序主要包括直接选择排序和堆排序;\n7. 交换排序主要包括冒泡排序和快速排序;\n8. 归并排序主要包括二路归并(常用的归并排序)和自然归并。\n9. 分配排序主要包括箱排序和基数排序\n\n\n## 冒泡排序\n- 冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不用交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法\n```js\n// js代码\nfunction sort(arr) {\nif (arr.length == 0) {\n    return [];\n}\nvar length = arr.length;\nfor (var i = 0; i < length; i++) {\n        for (var j = 0; j < length - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                var temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n                console.log(arr);\n            }\n        }\n    }\n}\n\n```\n\n\n## 快速排序\n- 快速排序是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列.\n- 时间复杂度：O（n*lgn）最坏：O（n^2）空间复杂度：O（n*lgn）\n\n```js\n// js递归实现\nfunction quickSort(arr) {\n    if (arr.length == 0) {\n        return [];\n    }\n    var left = [];\n    var right = [];\n    var pivot = arr[0];\n    for (var i = 1; i < arr.length; i++) {\n        if (arr[i] < pivot) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n    return quickSort(left).concat(pivot, quickSort(right));\n}\nvar a = [];\nfor (var i = 0; i < 10; ++i) {\n    a[i] = Math.floor((Math.random() * 100) + 1);\n}\nconsole.log(a);\nconsole.log(quickSort(a));\n```\n## 直接插入排序  \n- 直接插入排序(straight insertion sort)的作法是：每次从无序表中取出第一个元素，把它插入到有序表的合适位置，使有序表仍然有序.\n\n```js\nfunction insertionSort(arr) {\n    var temp, inner;\n    for (var outer = 1; outer <= arr.length - 1; ++outer) {\n        temp = arr[outer];\n        inner = outer;\n        while (inner > 0 && (arr[inner - 1] >= temp)) {\n            arr[inner] = arr[inner - 1];\n            --inner;\n        }\n        arr[inner] = temp;\n    }\n    return arr;\n}\nvar a = [];\nfor (var i = 0; i < 10; ++i) {\n    a[i] = Math.floor((Math.random() * 100) + 1);\n}\nconsole.log(a);\nconsole.log(insertionSort(a));\n```\n\n## 折半插入排序\n- 折半插入排序算法的具体操作为：在将一个新元素插入已排好序的数组的过程中，寻找插入点时，将待插入区域的首元素设置为a[low],末元素设置为 a[high]，则轮比较时将待插入元素与a[m],其中m=(low+high)/2相比较,如果比参考元素小，则选择a[low]到a[m-1]为新 的插入区域(即high=m-1)，否则选择a[m+1]到a[high]为新的插入区域（即low=m+1），如此直至low<=high不成 立，即将此位置之后所有元素后移一位，并将新元素插入a[high+1]\n\n\n## 希尔排序\n- 先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为dl的倍数的记录放在同一个组中。先在各组内进行直接插入 排序；然后，取第二个增量d2<d1重复上述的分组和排序，直至所取的增量dt=1(dt<dt-l<…<d2<d1)， 即所有记录放在同一组中进行直接插入排序为止。\n- 该方法实质上是一种分组插入方法。插入排序（Insertion Sort）的一个重要的特点是，如果原始数据的大部分元素已经排序，那么插入排序的速度很快（因为需要移动的元素很少）。从这个事实我们可以想到，如果原 始数据只有很少元素，那么排序的速度也很快。－－希尔排序就是基于这两点对插入排序作出了改进。\n\n\n## 直接选择排序\n- 直接选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么 交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。时间复杂度是O(n^2)\n\n\n## 堆排序\n- 我们知道堆的结构是节点i的孩子为2*i和2*i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, ...1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。\n\n\n\n## 二路归并排序\n- 归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的段序列合并成一个有 序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定 性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。\n","tags":["算法"],"categories":["algorithm"]},{"title":"Mysql优化的常用方法","url":"/mysql-optimize.html","content":"** mysql优化：** <Excerpt in index | 首页摘要>\n    mysql的优化措施，从sql优化做起\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 优化sql的一般步骤\n1. 通过show status了解各种sql的执行频率\n2. 定位执行效率低的sql语句\n3. 通过explain分析效率低的sql\n4. 通过show profile分析sql\n5. 通过trace分析优化器如何选择执行计划\n6. 确定问题，采取措施优化\n\n## 索引优化措施\n1. mysql中使用索引的典型场景\n    1. 匹配全值，条件所有列都在索引中而且是等值匹配\n    2. 匹配值的范围查找，字段必须在索引中\n    3. 匹配最左前缀，复合索引只会根据最左列进行查找\n    4. 仅仅对索引进行查询，即查询的所有字段都在索引上\n    5. 匹配列前缀，比如like 'ABC%',如果是like '%aaa'就不可以\n    6. 如果列名是索引，使用column is null会使用索引\n\n2. 存在索引但不会使用索引的典型场景\n    1. 以%开头的like查询不能使用b树索引\n    2. 数据类型出现隐式转换不能使用索引\n    3. 复合索引，查询条件不符合最左列原则\n    4. 用or分割的条件，如果前面的条件有索引，而后面的条件没有索引\n\n3. 查看索引使用的情况\n```\nshow status like 'Handler_read%';\n```\n如果Handler_read_rnd_next的值比较高，说明索引不正确或者查询没有使用到索引\n\n## 简单实用的优化方法\n1. 定期检查表和分析表\n分析表语法：\n```\nanalyze table 表名；\n```\n检查表语法：\n```\ncheck table 表名；\n```\n2. 定期优化表\n    - 对于字节大小不固定的字段，数据更新和删除会造成磁盘空间不释放，这时候就行优化表，可以整理磁盘碎片，提高性能\n语法如下：\n```\noptimize table user(表名)；\n```\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["mysql"],"categories":["数据库"]},{"title":"mac下mysql5.6字符集设置","url":"/mac-mysql-unicode.html","content":"** mac下mysql5.6字符集设置：** <Excerpt in index | 首页摘要>\n    在mac下设置mysql5.6字符集时踩过的坑，百分百保证有效\n<!-- more -->\n<The rest of contents | 余下全文>\n## 为什么要设置字符集\n1. 设置字符集主要是解决乱码问题，由于中文和英文编码不同导致，中文出现乱码，所以一般都设置为utf8格式\n2. 不同的字符集和编码占用的字节不同，选择适合的编码会提高数据库性能\n\n## mac下设置\n- 在/etc/my.cnf文件进行设置，如果没有此文件可以从/usr/local/mysql/support-files/拷贝，命令如下\n```\ncd /usr/local/mysql/support-files\nsudo cp my.cnf /etc/my.cnf\n```\n查看文件的读写权限，如果为644（rw- r-- r--）则改为(664) (rw- rw- r--)\n如果改为(666)(rw- rw- rw-)则修改以后配置文件不会生效\n```\nsudo chmod 664 /etc/my.cnf\n```\n\n- my.cnf设置如下：\n```\n[client]\ndefault-character-set=utf8\n[mysqld]\ncollation-server = utf8_unicode_ci\ninit-connect='SET NAMES utf8'\ncharacter-set-server = utf8\n[mysql]\ndefault-character-set=utf8\n```\n\n## 查看设置是否成功\n在命令行输入mysql，如果提示没有命令的话，在bash或者zsh的文件里修改，我用的是zsh，设置~/.zshrc,\n```\nexport MYSQL=\"/usr/local/mysql/bin/\"\nexport PATH=\"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:$MYSQL\"\n```\n在命令行输入mysql,进入mysql命令行后，输入`status;`或者`show variables like '%char%';`\n```\n| character_set_client     | utf8                                                    |\n| character_set_connection | utf8                                                    |\n| character_set_database   | utf8                                                    |\n| character_set_filesystem | binary                                                  |\n| character_set_results    | utf8                                                    |\n| character_set_server     | utf8                                                    |\n| character_set_system     | utf8                                                    |\n| character_sets_dir       | /usr/local/mysql-5.6.30-osx10.11-x86_64/share/charsets/\n```\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://geeksblog.cc\n","tags":["mysql"],"categories":["数据库"]},{"title":"Mysql学习笔记","url":"/mysql-study.html","content":"** mysql学习笔记：** <Excerpt in index | 首页摘要>\n\tmysql学习，基础的增删改查，数据库优化，索引，分片，集群搭建等等。\n<!-- more -->\n<The rest of contents | 余下全文\\>\n \n## mysql的特点\n1. 关系型数据库，免费使用，\n2. 插入式存储引擎，\n3. 性能高，\n\n## 基础的增删改查\n1. ddl语句，数据定义语句\n\t```\n\tcreate database test1;\n\tdrop database test1;\n\tuse test1;\n\tcreate table emp(ename varchar(10),hiredate date,sal decimal(10,2),deptno int(2));\n\tdrop table emp;\n\talter table emp modify ename varchar(20);\n\talter table emp add column age int(3);\n\talter table emp drop column age;\n\talter table emp change age age1 int(4);\n\talter table emp add birth date after ename;\n\talter table emp modify age int(3) first;\n\talter table emp rename emp1;\n\t```\n2. dml语句，数据操纵语句\n\t```\n\tinsert into emp(ename,hiredate,sal,deptno) values('zzx1','2000-10-11',2000,1);\n\tinsert into emp values('lisa','2004-05-09',3000,2);\n\tinsert into dept values(5,'dept5'),(6,'dept6');\n\tupdate emp set sal=4000 where ename='lisa';\n\tupdate emp a,dept b set a.sal=a.sal*b.deptno,b.deptname=a.ename where a.deptno=b.deptno;\n\tdelete from emp where ename='dony';\n\tdelete a,b from emp a,dept b where a.deptno=b.deptno and a.deptno=3;\n\tselect * from emp where ename='lisa';\n\tselect distinct deptno from emp;\n\tselect * from emp order by sal(desc);\n\tselect * from emp order by sal limit 5;\n\tselect * from emp order by sal limit 1,5;ss\n\n\t```\n3. dcl语句，数据控制语句\n\n## sql优化\n1. 尽量使用 prepareStatement(java)，利用预处理功能。\n2. 在进行多条记录的增加、修改、删除时，建议使用批处理功能，批处理的次数以整\n个 SQL 语句不超过相应数据库的 SQL 语句大小的限制为准。\n3. 建议每条 SQL 语句中 in 中的元素个数在 200 以下，如果个数超过时，应拆分为多\n条 SQL 语句。禁止使用 xx in(‘’,’’….) or xx in(‘’,’’,’’)。 ★\n4. 禁止使用 or 超过 200，如 xx =’123’ or xx=’456’。 ★\n5. 尽量不使用外连接。\n6. 禁止使用 not in 语句，建议用 not exist。 ★\n7. 禁止使用 Union, 如果有业务需要，请拆分为两个查询。 ★\n8. 禁止在一条 SQL 语句中使用 3 层以上的嵌套查询，如果有，请考虑使用临时表或\n中间结果集。\n9. 尽量避免在一条 SQL 语句中从>= 4 个表中同时取数， 对于仅是作为过滤条件关联，\n但不涉及取数的表，不参与表个数计算\n10. 查询条件里任何对列的操作都将导致表扫描，所以应尽量将数据库函数、计算表达\n式写在逻辑操作符右边。\n11. 在对 char 类型比较时,建议不要使用 rtrim()函数,应该在程序中将不足的长度补\n齐。\n12. 用多表连接代替 EXISTS 子句。\n13. 如果有多表连接时， 应该有主从之分， 并尽量从一个表取数， 如 select a.col1, a.col2\nfrom a join b on a.col3=b.col4 where b.col5 = ‘a’。\n14. 在使用 Like 时，建议 Like 的一边是字符串，表列在一边出现。\n15. 不允许将 where 子句的条件放到 having 中。\n16. 将更新操作放到事务的最后执行。如\n17. 一个事务需更新多个对象时，需保证更新的顺序一致以避免死锁的发生。如总是先\n更新子表再更新主表，根据存货档案批量更新现存量时，对传入的存货档案 PK 进\n行排序，再做更新处理等。\n18. 禁止随意使用临时表，在临时数据不超过 200 行的情况下禁止使用临时表。\n29. 禁止随意使用 distinct，避免造成不必要的排序。\n\n## 索引优化\n1. 创建索引，删除索引\n```\ncreate index cityname on city(city(10));\ndrop index cityname on city;\n```\n2. 搜索的索引列最好在where的字句或者连接子句\n3. 使用唯一索引\n4. 使用短索引，对于较长的字段，使用其前缀做索引\n5. 不要过度使用索引，索引引起额外的性能开销和维护\n\n## 高级优化措施\n\n## 集群搭建\n","tags":["mysql"],"categories":["数据库"]},{"title":"Nodejs开发规范","url":"/node-develop.html","content":"** nodejs开发规范：** <Excerpt in index | 首页摘要>\n    nodejs开发中应当遵循的规范，以及最佳实践\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## node开发需要编程规范吗？\n1. js的灵活性非常大，如果开发人员每个人都按自己的习惯随意编写，js的代码会非常混乱不堪。js程序员需要更强的自律性和规范，才能写出易读性，易维护的代码。\n2. 随着前端mvc的崛起，前端的js代码会更加庞大难以管理，如果没有统一的规范，后期维护会比登天还难。\n\n## 编码规范\n\n1. 缩进\n采用两个空格缩进，在编辑器中设置tab为两个空格\n\n2. 变量声明\n- 用var声明变量\nvar assert = require('assert');\nvar fork = require('child_process').fork;\nvar net = require('net');\n\n错误实例：\nvar assert = require('assert')\n, fork = require('child_process').fork\n, net = require('net')；\n\n- 用字面量声明方式\nvar num = 123;\nvar aaa = {};\nvar arr = [];\nvar isAdmin = true;\n- 避免使用：\nvar obj =new Object();\nvar arr = new Array();\nvar test  =new String(\"\");\nvar size = new Number();\n\n- 不要在for循环等循环里声明var变量\n首先var是函数作用域，在循环声明以后只有等函数声明周期结束这些资源才会释放\n\n\n3. 空格\n在操作符前后需要加上空格,= 、% 、* 、- 、+ 前后都应该加一个空格\n比如：var foo = 'bar' + baz;\n错误实例：var foo='bar'+baz;\n\n4. 单双引号的使用\n在node中尽量使用单引号，\nvar html = '<a href=\"http://cnodejs.org\">CNode</a>';\n 在json中使用双引号\n\n5. 分号\n给表达式结尾加分号，尽管js会自动在行尾加上分号，但是会产生一些误解\n\n## 命名规范\n在编码中，命名是重头戏。好的命名可以使代码赏心悦目，具有良好的维护性。\n\n1. 变量命名\n变量名采用小驼峰命名，单词之间没有任何符号如：\nvar adminUser = {};\nvar callNum = 2134323;\n2. 方法命名\n也是采用小驼峰命名，与变量不同的是采用动词或判断行词汇，如：\nvar getUser = function(){};\nvar isAdmin = function(){};\nvar findUser = function(){};\n\n3. 类命名\n类名采用大驼峰，所有单词首字母大写，如：\nfunction User{}\n\n4. 常量命名\n作为常量，单词所有字母大写，用下划线分割，如：\nvar PINK_COLOR = \"PINK\";\n\n5. 文件命名\n命名文件时，尽量使用下划线分割单词，比如child_process.js和string_decode.js\n\n6. 包名\n在包名中尽量不要包含js和node的字样，应当适当短并且有意义\n\n## 其它要点\n\n1. 作用域\n慎用with和eval（），容易引起作用域混乱\n\n2. 比较操作\n尽量使用===代替==,否则会遇到下面的情况，'0'==0;//true;\n ''==0;//true;\n '0'===''//false;\n\n3. 严格模式\n在node后台中尽量全使用严格模式\n'use strict';\n\n4. 对象和数组遍历\n数组遍历使用普通for循环，避免使用for in对数组遍历，\n对象的遍历使用for in\n\n## 项目中实践\n1. sublime和webstorm都有JSLint,JSHint这样的代码质量工具，在配置文件中制定好模板规范即可\n\n2. 在版本控制工具中设置hook，在precommit的脚本中设置，如果代码不符合标准，就无法提交\n\n##  参考文献\n1. 深入浅出nodejs\n2. js秘密花园\n3. js高级编程\n","tags":["node"],"categories":["编程语言"]},{"title":"Redis学习笔记","url":"/redis-study.html","content":"** redis学习笔记：** <Excerpt in index | 首页摘要>\n    redis数据库的基本操作，增删改查\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## keys\nredis本质上是一个key-value数据库\n1. 设置：set key value\n2. 获取：get key\n3. 判断存在：exists key\n4. 删除：del key\t\tdel  test:fan:age\n5. 重命名：rename  oldkey newkey\t\t\n6. 数量：dbsize  返回数据\n7. 获取所有key（通配符）：`Keys test:*:age`\n`Keys test:?:age`\n8. 清空：flushdb\tflushall\n9. 设置有效时间：expire test:fan:age 30\n10. 查询有效时间：ttl test:fan:age\n\n## String类型\n1. 设置：\n\tset key value\n\tsetnx ky value(nx是not exist)\n\tmset key1 value1 keyN valueN\n\tmsetnx key1 value1 keyN valueN\n2. 获取：\n\tget\t\t\t不存在返回nil\n\tgetset\t\t设置key的值，并返回key的旧值，不存在返回nil\n\tmget\t\t\n3. 自增减：\n\tincr key   对key的值进行++操作，返回新的值\n\tdecr key\n\tincrby key integer\t\t对key加上一个数值\n\tdecrby key integer\n4. 截取：\n\tsubstr key indexStart indexEnd \t\t\t下标从0开始\n5. 追加：\n\tappend key value\n\n## list类型\nredis的list其实就是一个每个元素都是string 的双向链表，所以push和pop的时间复杂度都是O（1）\n1. 添加\n\tlpush key string \t\t在头部添加\n\trpush key string\t\t在尾部添加\n2. 修改\n\tlset key index value  修改指定下标的key的值\n3. 删除\n\tlpop key \t从头部返回删除\n\trpop key  从尾部\n\tlrem key count value  删除count个相同的value，count为0删除全部\n\tblpop key ...keyN timeout\n\tbrpop 从尾部删除\n4. 获取\n\tlrange key indexStart indexEnd\n5. 数量\n\tllen key\t\t返回key对应的list长度\n6. 截取\n\tltrim key start end\n7. 转移\n\trpoplpush key1 key2\t从key1尾部移到key2头部\n\n## set集合\nredis的set就是String的无序集合，通过hashtable实现\n1. 添加\n\tsadd key member\n2. 删除\n\tsrem key member\t\t移除指定的元素\n\tspop key \t\t\t\t\t删除并返回一个随机的\n3. 获取\n\tsmembers key\t\t\t返回所有\n\tsrandmember\t\t\t随机取一个不删除\n4. 判断存在\n\tsismember key member\n5. 数量\n\tscard key \t\t\t\t\t返回元素个数\n6. 转移\n\tsmove srckey dstkey member\n7. 取交集\n\tsinter key1 key2 keyN\n\tsinterstore dstkey key1 keyN\t\t将交集存在dstkey\n8. 取并集\n\tsunion key1 key2 keyN\n\tsunionstore dstkey key1 keyN\t将并集存在dstkey\n9. 取差集\n\tsdiff key1 key2 keyN\n\tsdiffstore dstkey key1 keyN\t\t将差集存在dstkey\n\n## 有序set类型\n和set一样，不同的是每个元素关联一个double类型的score，根据score排序，sorted set的实现由skip list和hashtable\n1. 添加\n\tzadd key score member\n2. 删除\n\tzrem key member\n\tzremrangebyrank key min max\n\tzremrangebyscore key min max \t删除集合score在给定区间的元素\n3. 获取\n\tzrange key start end\n\tzrevrange\tkey start end\t\t\t按score的逆序\n\tzrangebyscore key min max\t\t\n4. 判断存在\n\tzrank key member\t\t返回下标\n\tzrerank key member\t\t返回逆序的下标\n5. 数量\n\tzcard key\t\t\t\t\t\t总数\n\tzcount key min max \t\t区间的数量\n6. 修改\n\tzincrby key incr member\t增加member的score值并排序\n\n## hash类型\nredis的hash是一个string类型的field和value的映射表，hash特别适合存储对象，\n1. 设置：\n\thset key field value\n\thmset key field1 value1 field2 value2\n2. 获取：\n\thget key field\n\thmget key field1 field2\n3. 判断存在\n\thexists key field\n4. 删除\n\thdel key field\n5. 查找\n\thkeys key\t\t\t返回所有 field\n\thvals key\t\t\t返回所有的value\n\thgetall key\t\t返回所有field和value\n6. 数量\n\thlen key\n7. 值加减\n\thincrby key field integer\t将指定的hash field加上定值\n","tags":["redis"],"categories":["数据库"]},{"title":"Git比svn的优势","url":"/git-svn.html","content":"** git比svn的优势：** <Excerpt in index | 首页摘要>\n    主要介绍svn和git在使用的时候一些区别\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 合并操作时对提交过程的保留\n- git:合并操作保留原有的提交过程\n- svn:多个提交合并为一个提交\n- 不用因为合并操作而导致追踪的困难\n\n## 修正提交\n- git：可以修正提交。  \n使用功能分支工作流，在自己的分支可以方便修正提交而不会影响大家。\n- svn：一旦提交就到服务器上，实际使用中就是不能修改  \n（svn可以在服务器上修改，因为过程复杂需要权限实际上从不会这样做）\n\n\n## 本地分支\n- git可以方便的创建本地分支,创建时间极短,分支可以是本地的,不会存在svn中目录权限的问题\n\n## 强大的合并能力\n- git：重命名（无论文件还有目录）提交 可以合并上 文件重命名前的这些文件的提交\n\n- svn：重命名（无论文件还有目录）提交后，你本地/或是分支上 有文件重命名前的这些文件的修改或提交，在做合并操作时,你会碰上传说中难搞的***树冲突***！\n\n- 这就导致在调整目录名称和类名调整的时候比较繁琐,需要告诉大家,我修改完以后你再修改\n\n\n## tag的支持\n\n- svn在模型上是没有分支和tag的。tag是通过目录权限限制（对开发只读）来保证不变。\n- git模型上一等公民支持tag，保证只读。\n\n## 速度优势\n\n- git的提交是个本地提交,相对svn来说如闪电一般\n- git提供了暂存区,可以方便制定提交内容,而不是全部内容\n\n## 日志查看\n- git：本地包含了完整的日志，闪电的速度（并且无需网络)\n- svn：需要从服务拉取。\n- 一旦用了git后，等待svn日志过程简直让我发狂\n","tags":["others"],"categories":["开发工具"]},{"title":"Java和javascript日期详解","url":"/java-date.html","content":"** java，js日期转换：** <Excerpt in index | 首页摘要>\n    java的各种日期转换\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 日期表示类型\n1. 获取long类型的日期格式\n```java\nlong time = System.currentTimeMillis();\nSystem.out.printf(time+\"\");\nDate date =new Date();\nSystem.out.println(date.getTime());\n```\n2. 获取制定格式的日期\n```java\nSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\nDate date =new Date();\nSystem.out.println(sdf.format(date) );\n```\n3. 把制定格式的日期转为date或者毫秒值\n```java\nSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\nDate date = sdf.parse(\"2016-05-22 10:15:21\");\nlong mills = date.getTime();\n```\n- 说明:System.currentTimeMillis()并不能精确到1ms的级别,它取决于运行的系统,你再windows,mac,linux精确的范围都有差异,对于有高精度时间的要求,不能使用这个\n\n## 日期计算\n1. 最方便的方式是将时间转为毫秒值进行计算\n```java\nDate from =new Date();\nThread.sleep(200);//线程休眠2ms\nDate to =new Date();\nSystem.out.println(to.getTime()-from.getTime());\n```\n\n## 高精度时间\n```java\nlong time1 =System.nanoTime();\nSystem.out.printf(time1+\"\");\n```\n- 说明:System.nanoTime()提高了ns级别的精度,1ms=1000000ns,\n\n## javascript日期\n1. 获取时间的毫秒值，获取月份，时间\n```js\nvar myDate = new Date();\nmyDate.getYear(); //获取当前年份(2位)\nmyDate.getFullYear(); //获取完整的年份(4位,1970-????)\nmyDate.getMonth(); //获取当前月份(0-11,0代表1月)\nmyDate.getDate(); //获取当前日(1-31)\nmyDate.getDay(); //获取当前星期X(0-6,0代表星期天)\nmyDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数)\nmyDate.getHours(); //获取当前小时数(0-23)\nmyDate.getMinutes(); //获取当前分钟数(0-59)\nmyDate.getSeconds(); //获取当前秒数(0-59)\nmyDate.getMilliseconds(); //获取当前毫秒数(0-999)\nmyDate.toLocaleDateString(); //获取当前日期\nvar mytime=myDate.toLocaleTimeString(); //获取当前时间\nmyDate.toLocaleString( ); //获取日期与时间\n```\n2. 时间戳获取\n注意，java，php等生成的时间戳是秒，不是毫秒，所以需要签名时间戳的时候，需要转为秒时间戳\n```js\nvar time = new Date();\nvar timestamp = parseInt(time.getTime()/1000);\n```\n3. 格式化时间\n```js\n//获取当前时间，格式YYYY-MM-DD\nfunction getNowFormatDate() {\n    var date = new Date();\n    var seperator1 = \"-\";\n    var year = date.getFullYear();\n    var month = date.getMonth() + 1;\n    var strDate = date.getDate();\n    if (month >= 1 && month <= 9) {\n        month = \"0\" + month;\n    }\n    if (strDate >= 0 && strDate <= 9) {\n        strDate = \"0\" + strDate;\n    }\n    var currentdate = year + seperator1 + month + seperator1 + strDate;\n    return currentdate;\n}\n```\n","tags":["java"],"categories":["编程语言"]},{"title":"制定学习目标和计划","url":"/study-goals.html","content":"** 制定学习目标和计划：** <Excerpt in index | 首页摘要>\n\t近期的学习目标和学习重点,提高自己的能力\n <!-- more -->\n<The rest of contents | 余下全文>\n\n## 找到自己的兴趣\n- 自己主动学习一定要基于自己的兴趣,不要看什么框架流行,什么语言火,就去学,学的不温不火,然后放弃.\n- 一定看自己的兴趣,比如你对色彩,对布局,对特效比较痴迷,那你去css3,html5做出特酷的效果,肯定能让你肯定自己,\n收获知识和自信.\n- 没有兴趣的时候,可以适当的多接触一些东西,在最短的时间多接触一些领域,让自己的心去做选择,\n\n## 制定目标\n1. 为什么要制定目标?\n- 制定目标是对自己学习能力的检验,同时也是提高学习效率的关键,而不是自己没有目的的瞎看,\n2. 如何制定目标?\n- 结合自身的能力,定制比自己能力稍高的目标,这样自己通过一定程度的努力可以实现目标.这样自己的能力能一次一次提高.\n\n## 及时反馈\n- 古人说的好,吾日三省吾身,对待学习目标也是一样,要时不时的看自己的目标完成的如何,进度如何,是不是需要调整,不能闷着头蛮干,方向错了,再多的努力也是白搭了.\n\n## 总结\n- 我在刚开始学编程的时候,每天都给自己定制了目标,一天完成多少课时,完成多少练习,都是按量完成,在最初的几个月收到了立竿见影的效果,让我也在短短三个月的时间学会了java,所以,目标的制定对于结果的影响是非常大.\n","tags":["others"],"categories":["个人随笔"]},{"title":"使用Ghost搭建个人博客","url":"/ghost-blog.html","content":"** 使用ghost搭建个人博客：** <Excerpt in index | 首页摘要>\n\t使用ghost搭建个人博客\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## ghost简介\n- ghost是轻量级的博客建站工具,使用起来简单,功能强大,适合个人搭建小型网站,个人博客,或者个人展示的网站\n- ghost基于nodejs,对于熟悉js的前端小伙伴来说,入手起来也是简单不少.\n\n## 准备工作\n1. 安装nodejs\n2. 安转git\n3. 配置ssh\n4. 下载ghost\n3. 购买域名\n\n## 搭建博客\n\n## 定制个人博客\n\n## 享受吧\n","tags":["others"],"categories":["开发工具"]},{"title":"Git学习笔记","url":"/git-config-study.html","content":"** git学习笔记：** <Excerpt in index | 首页摘要>\n\tgit的常用操作，高级技巧都要哦\n<!-- more -->\n<The rest of contents | 余下全文\\>\n\n## 安装git\n1. 下载安装包 ￼下载地址￼\n2. 安装git\n3. 进入命令行,输入git看看是否成功\n\n## 配置git\n1. 配置全局用户名和密码\n\t\\`git config --global user.name \"John Doe\"\n\tgit config --global user.email johndoe@example.com\n\t\\`\n2. 配置ssh公钥\n\t`cd ~/.ssh` 然后`ls`\n\t如果没有,直接生成,一路点击enter\n\t\\`\\`\\`\n\tssh-keygen\n\tcat \\~/.ssh/id\\_rsa.pub\n\t\\`\\`\\`\n\t把公钥配置到github的个人设置\n\n## 常用的命令\n1. repository操作\n\t- 检出（clone）仓库代码：`git clone repository-url` / `git clone repository-url local-directoryname`\n\t\t+ 例如，clone jquery 仓库到本地： `git clone git://github.com/jquery/jquery.git`\n\t\t+ clone jquery 仓库到本地，并且重命名为 my-jquery ：`git clone git://github.com/jquery/jquery.git my-jquery`\n\t- 查看远程仓库：`git remote -v`\n\t- 添加远程仓库：`git remote add [name] [repository-url]`\n\t- 删除远程仓库：`git remote rm [name]`\n\t- 修改远程仓库地址：`git remote set-url origin new-repository-url`\n\t- 拉取远程仓库： `git pull [remoteName] [localBranchName]`\n\t- 推送远程仓库： `git push [remoteName] [localBranchName]`\n\n2. 提交/拉取/合并/删除\n\t- 添加文件到暂存区（staged）：`git add filename` / `git stage filename`\n\t- 将所有修改文件添加到暂存区（staged）： `git add --all` / `git add -A`\n\t- 提交修改到暂存区（staged）：`git commit -m 'commit message'` / `git commit -a -m 'commit message'` 注意理解 -a 参数的意义\n\t- 从Git仓库中删除文件：`git rm filename`\n\t- 从Git仓库中删除文件，但本地文件保留：`git rm --cached filename`\n\t- 重命名某个文件：`git mv filename newfilename` 或者直接修改完毕文件名 ，进行`git add -A && git commit -m 'commit message'` Git会自动识别是重命名了文件\n\n\t- 获取远程最新代码到本地：`git pull (origin branchname)` 可以指定分支名，也可以忽略。pull 命令自动 fetch 远程代码并且 merge，如果有冲突，会显示在状态栏，需要手动处理。更推荐使用：`git fetch` 之后 `git merge --no-ff origin branchname` 拉取最新的代码到本地仓库，并手动 merge 。\n\n3. 日志查看\n\t- 查看日志：`git log`\n\t- 查看日志，并查看每次的修改内容：`git log -p`\n\t- 查看日志，并查看每次文件的简单修改状态：`git log --stat`\n\t- 一行显示日志：`git log --pretty=oneline` / `git log --pretty='format:\"%h - %an, %ar : %s'`\n\t- 查看日志范围：\n\t\t+ 查看最近10条日志：`git log -10`\n\t\t+ 查看2周前：`git log --until=2week` 或者指定2周的明确日期，比如：`git log --until=2015-08-12`\n\t\t+ 查看最近2周内：`git log --since=2week` 或者指定2周明确日志，比如：`git log --since=2015-08-12`\n\t\t+ 只查看某个用户的提交：`git log --committer=user.name` / `git log --author=user.name`\n4. 取消操作\n\t- 上次提交msg错误/有未提交的文件应该同上一次一起提交，需要重新提交备注：`git commit --amend -m 'new msg'`\n\t- 一次`git add -A`后，需要将某个文件撤回到工作区，即：某个文件不应该在本次commit中：`git reset HEAD filename`\n\t- 撤销某些文件的修改内容：`git checkout -- filename` 注意：一旦执行，所有的改动都没有了，谨慎！谨慎！谨慎！\n\t- 将工作区内容回退到远端的某个版本：`git reset --hard <sha1-of-commit>`\n\t\t+ `--hard`：reset stage and working directory ,<commitid> 以来所有的变更全部丢弃，并将 HEAD 指向<commitid>\n\t\t+ `--soft`：nothing changed to stage and working directory ,仅仅将HEAD指向<commitid> ，所有变更显示在”changed to be committed”中\n\t\t+ `--mixed`：default,reset stage ,nothing to working directory ，这也就是第二个例子的原因\n\n5. 比较差异\n\t- 查看工作区（working directory）和暂存区（staged）之间差异：`git diff`\n\t- 查看工作区（working directory）与当前仓库版本（repository）HEAD版本差异：`git diff HEAD`\n\t- 查看暂存区（staged）与当前仓库版本（repository）差异：`git diff --cached` / `git diff --staged`\n\n6. 合并操作\n\t- 解决冲突后/获取远程最新代码后合并代码：`git merge branchname`\n\t- 保留该存在版本合并log：`git merge --no-ff branchname` 参数`--no-ff`防止 fast-forward 的提交\n","tags":["others"],"categories":["学习笔记"]},{"title":"Ubuntu16服务器环境配置","url":"/ubuntu-dev-config.html","content":"** ubuntu开发环境配置：** <Excerpt in index | 首页摘要>\n    ubuntu16下node,java开发环境配置\n <!-- more -->\n<The rest of contents | 余下全文>\n\n## ubuntu14升级到ubuntu16\n1. 终端下执行命令\n`sudo apt-get update && sudo apt-get dist-upgrade`\n2. 重启系统以完成更新的安装\n`sudo init 6`\n3. 用命令安装更新管理器核心update-manager-core，如果服务器已安装则可以跳过\n`sudo apt-get install update-manager-core`\n4. 编辑/etc/update-manager/release-upgrades配置文件，设置Prompt=lts\n`sudo vi /etc/update-manager/release-upgrades`\n5. 启动升级进程\n`sudo do-release-upgrade -d`\n\n## 安装系统软件\n1. 更新系统和软件\n   ```\n   sudo apt-get update\n   sudo apt-get upgade\n   ```\n2. 谷歌浏览器，火狐浏览器，atom编辑器，sublime编辑器，webstome,idea,eclipse\n3. 安装搜狗输入法（官网），安装fcitx配置搜狗输入法\n## 安装jdk\n1. 下载jdk并新建一个文件夹\n    ```\n    sudo mkdir /usr/lib/jvm\n    ```\n2. 解压文件\n    ```\n    sudo tar zxvf jdk-7u71-linux-x64.tar.gz -C /usr/lib/jvm/jdk1.7\n    ```\n3. 设置环境变量,设置~/.zshrc文件,或者编辑/etc/profile（全局）文件\n    ```\n    export JAVA_HOME=/usr/lib/jvm/jdk1.7\n    export JRE_HOME=${JAVA_HOME}/jre  \n    export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  \n    export PATH=${JAVA_HOME}/bin:$PATH\n    ```\n4. 检查是否安装成功\n    打开shell,\n    ```\n    java --version\n    ```\n\n## 安装nodejs\n1. nodejs版本迭代较快，有时候需要检查在不同版本下的兼容性问题，用nvm来控制版本\n2. 安装nvm,source的时候根据自己的shell版本，~/.bashrc, ~/.profile, 或者 ~/.zshrc\n    ```\n    curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash\n    export NVM_DIR=\"$HOME/.nvm\"\n    [ -s \"$NVM_DIR/nvm.sh\" ] && . \"$NVM_DIR/nvm.sh\" # This loads nvm\n    source ~/.profile\n    ```\n3. 安装不同版本的nodejs\n　　```\n    nvm ls-remote\n    nvm install v0.12.9\n    nvm install 5.0\n    nvm use 0.12.9\n    nvm alias default 0.12.9\n    ```\n\n## 安装mongodb\n1. 配置公钥\n```bash\nsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10\necho \"deb http://repo.mongodb.org/apt/ubuntu \"$(lsb_release -sc)\"/mongodb-org/3.0 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.0.list\n```\n2. 更新软件列表\n```bash\nsudo apt-get update\nsudo apt-get install -y mongodb-org\n```\n3. 完成上面的安装步骤配置mongodb的数据库的位置\n```bash\nsudo mongod --dbpath /data/db\n```\n4. 启动mongod\n```bash\nsudo service mongod start\nsudo service mongod stop\nsudo service mongod restart\n```\n\n## 安装redis\n1. 下载软件\n```bash\nwget http://download.redis.io/releases/redis-2.8.11.tar.gz\n```\n2. 解压安装\n```bash\ntar xvfz redis-2.8.11.tar.gz\ncd redis-2.8.11 && sudo make && sudo make install\n```\n3. 配置使用\n    1. 下载配置文件和init启动脚本\n    ```bash\n    wget https://github.com/ijonas/dotfiles/raw/master/etc/init.d/redis-server\n    wget https://github.com/ijonas/dotfiles/raw/master/etc/redis.conf\n    sudo mv redis-server /etc/init.d/redis-server\n    sudo chmod +x /etc/init.d/redis-server\n    sudo mv redis.conf /etc/redis.conf\n    ```\n    2. 初始化用户和日志路径\n    ```bash\n    sudo useradd redis\n    sudo mkdir -p /var/lib/redis\n    sudo mkdir -p /var/log/redis\n    sudo chown redis.redis /var/lib/redis\n    sudo chown redis.redis /var/log/redis\n    ```\n    3. 设置开机自动启动，关机自动关闭\n    ```bash\n    sudo update-rc.d redis-server defaults\n    ```\n\n## 环境变量配置\n1. 认识环境变量相关的文件\n- /etc/profile —— 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置；\n- /etc/environment —— 在登录时操作系统使用的第二个文件,系统在读取你自己的profile前,设置环境文件的环境变量；\n- /etc/bashrc —— 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取；\n- ~/.profile —— 每个用户都可使用该文件输入专用于自己使用的shell信息，当用户登录时，该文件仅仅执行一次！默认情况下,它设置一些环境变量,执行用户的.bashrc文件；\n- ~/.bashrc —— 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取；\n2. 配置环境变量\n- 在Ubuntu14.04的~/.bashrc中添加的环境变量,在文件添加\n``` bash\nexport PATH=$PATH:/home/qtcreator-2.6.1/bin\n```\n- 修改profile文件,vim编辑/etc/profile\n```bash\nsudo vim /etc/profile\nsource /etc/profile\n```\n\n## 安装开发工具\n1. zsh命令行工具\n2. mysql客户端workbench，mongo客户端工具robomongo\n3. 安装git,svn版本控制工具\n```bash\nsudo apt-get install git\nsudo apt-get install subversion\n```\n","tags":["linux"],"categories":["开发工具"]},{"title":"我的梦想","url":"/dream.html","content":"** 我的梦想：** <Excerpt in index | 首页摘要>\n    一个人如果活着没有梦想,那和咸鱼有什么区别?\n<!-- more -->请问你的梦想是什么?\n<The rest of contents | 余下全文>\n\n## 我的梦想是什么?\n- 刚开始接触编程的时候,感觉代码是个神器的世界,在这里你可以为所欲为,然后看到很多大神的框架,软件,在使用别人好的框架,好的软件,那一刻我感觉 <strong>\"我的梦想就是用代码改变世界!\"</strong>\n\n- 感觉自己迷失了好久,找不到方向,曾经的激情不知道去了哪里?\n\n## 开始追梦\n- 有了梦想,我开始了疯狂的奋斗,每天休息4,5个小时,全身心去学习编程,努力还是很快得到了回报,我用了3个月就入门学好了java,然后找了java程序员的工作,就这样开始了我程序员的追梦之旅!\n\n## 初级程序员\n\n- 虽然入门了,但是刚开始的工作并不是一帆风顺的.我还记得第一份任务,老大让我写一个稍微复杂的接口,客户专用的接口,使用springmvc,还要提交到git上,对我而言,这一切都是新东西,经过我几天的努力,还是搞砸了,就这样第一个任务以失败告终!\n- 虽然第一个任务失败了,但是工作还在继续,我还是继续努力的工作,我必须承认我不是编程的天才,可能别人一个小时完成的任务,我需要一个半小时,但是我必须做好,因为我有梦想!\n\n## 中级程序员\n- 在工作的时候就感觉时间飞逝,一天天很快过去.晚上睡觉的时候,我就会问自己,我今天到底做了什么功能?我收获了哪些技能?曾经有段时间每天都是该页面,我几乎烦的崩溃,感觉每天都在做无用的东西,后来发现,无论是前段后端,其实都是必不可少的技能,我的心态应该调整,让自己去喜欢前段,同时保持后端的热情.\n\n- 一个成熟的程序员和菜鸟最大的区别应该是心态!\n\n## 高级程序员\n- 不再是代码搬运工，根据业务和需求自己随便造个轮子什么的。强大的代码能力，考虑事情应该全面，深刻\n\n## 架构师\n- 未完待续\n","tags":["others"],"categories":["个人随笔"]},{"title":"程序员入门指南","url":"/coder-study.html","content":"** 程序员入门指南 ：** <Excerpt in index | 首页摘要>\n        程序员入门必须了解的一些知识，个人经验，不喜勿喷！\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 程序员的入门规划\n## 1.我该学习什么语言？\n\n- 这个问题困扰了几乎所有的程序员，比如java应用广好就业，比如php入门简单，ios待遇高，  python是万能语言，HTML和js前端缺人才等等\n\n- 个人见解：先学习难度小，大众化的编程语言，比如java，php，python，javascript,c/c++,这几个学哪一种其实差不多，入门以后看自己兴趣在进行其它语言的学习。\n\n## 2.我该怎么学习编程？\n\n这个问题是所有的程序员都有的，我也经常会疑问，到底该怎么学习呢？\n\n个人见解：\n\n1. 先了解语言的特性，适用的范围场景，比如是适合web开发，还是适合客户端程序，有的适合并发多线程，有的适合异步，还有的比较稳定，适合构建大型项目，有的开发效率高，等等。\n2. 了解语言的语法和常用api的使用，比如变量的声明，循环的使用，io的读取，http服务的创建，把这些基本的语法搞清楚，在进行下一步的学习。\n3. 学习web开发之前的准备，数据库的学习，http协议的学习，html，css和javacript的常用知识了解\n4. 学习常用框架，比如java学习常用的ssh三大框架，node的学习express，一定要做2个项目练习，把自己的之前学习的知识都巩固一下，\n5. 总结一下自己学习的过程，明白编程的思想在哪里，思路在哪里，学习编程，首先应该培养的是编程的思维和思想，有个正确的思维后面都简单多了。\n6. 养成写博客或者学习笔记的习惯，推荐写博客，\n7. 熟悉项目管理工具，svn，git之类的必须要会，工作中这些都是必须的\n8. 准备面试，通过面试题进一步巩固自己的知识，夯实基础。\n\n## 3.我应该去哪里学习编程？\n\n其实这个看个人，如果自学能力强，自控能力强，自学挺好的，下面我列举几个程序员常用的网站  \n\n1. [网易云课堂][1]，很多免费的视频课程，适合入门学习\n2. [慕课网][2]，很多it入门教学视频，资源也不错\n3. [极客学院][3]，和前两个网站差不多，\n4. [北风网][4]，类似的教学网站，其它的就不说了\n\n## 4.编程遇到问题怎么办？\n * 百度或者谷歌看看网上有没有类似的问题，一回生，二回熟，很快就明白了\n * 去官网查看api文档查找原因\n * 自己要学会debug代码，查找原因\n * 去各大论坛逛逛，说不定早有人提问此类问题了\n\n\n## 5.我想看编程的书籍去哪找呢？\n经典书籍还是买纸质的，买正版的，支持正版！\n\n1. [新浪微盘][5]，非常多的it书籍  \n2. [脚本之家][6]，非常多的pdf书籍，可惜大多数不是文字版pdf  \n3. [英文原版书籍][7]，都是高清文字版pdf，强烈推荐，都是英文原版的  \n4. [计算机书控][8]，都是免费的pdf文档，大多数不是文字版pdf\n\n## 6.代码资源\n1. 最好的代码仓库 [github](https://github.com/)\n2. [csdn代码仓库](https://code.csdn.net/)\n3. [gist](https://gist.github.com/)\n4. [代码片段之家](http://www.phpxs.com/code/)\n\n## 7.学习心态\n\n1. 不要老是折腾工具，ide工具和文本编辑器一样一个就够了\n2. 不要自满，编程的东西学一辈子也学不会，要谦虚好学\n3. 不要急躁，既然知识学不完，我们应该掌握学习方法，指定计划去学习\n4. 要持之以恒，学习是一辈子的事，如果你没有这个打算，还是不要做程序员的好\n5. 切忌眼高手低，必须要敲代码才能达到效果\n\n## 8.编程进阶之路\n当有了一定的编程基础之后,最大的问题是确定自己的方向,这个时候最容易迷茫和困惑,学习什么技术?怎么去学,这些真的很难\n   - 个人建议如下:  \n    1.技术型方向:提高自己的编程能力和语言造诣,最有效的是\"造轮子\",量变引起质变\n   - 写插件,写框架,写爬虫,写数据库,自制编程语言,等等.\n    2.业务型方向:提高自己的业务能力,和客户的沟通能力,分析需求,解决客户的难题\n   - 多出去见客户,去现场,了解需求,分析需求,\n\n\n\n[1]: http://study.163.com/\n[2]: http://www.imooc.com/\n[3]: http://www.jikexueyuan.com/\n[4]: http://www.ibeifeng.com/\n[5]: http://vdisk.weibo.com/\n[6]: http://www.jb51.net/\n[7]: http://www.salttiger.com/\n[8]: http://bestcbooks.com/\n","tags":["others"],"categories":["编程语言"]},{"title":"Hexo和github打造个人博客","url":"/hexo-githup-blog.html","content":"** hexo和github打造个人博客 ：** <Excerpt in index | 首页摘要>\n    使用hexo和github打造属于自己的静态博客，展示自己的作品，思想……\n<!-- more -->\n<The rest of contents | 余下全文>\n\n##说明\n    自己在使用hexo搭建静态博客的时候踩了许多坑,最终去官网看教程搞定了,  \n    建议用hexo搭建个人博客的时候,最好看清教程的日期和使用的版本,这样就  \n    不会因为版本的不同导致的问题了.建议先去hexo官网了解一下\n   [**hexo官网**][1]\n## 1.准备工作\n 1. 安装nodejs\n    - 去官网下载nodejs安装(推荐安装4.x),安装之后在命令行 node -v,如果成功说明node环境ok,不成功就去环境变量配置一下.\n 2. 安装hexo\n    - 使用命令 npm install hexo -g,执行hexo -v 查看版本,本教程适合**3.1.1以上**版本\n 3. 安装git\n    - 去官网下载git安装,不会自行百度\n 4. 配置git\n    - 配置ssh私钥,上传到github上\n\n## 2.github-pages的说明\n\n 1. github有两种主页,一种是github-page(个人主页),一种是项目主页,本教程针对个人主页\n 2. github-page需要将hexo博客发布到repository的master(主干)即可\n 3. github的个人主页要求repository的名称和username一致，加入username是tom，则repository的名称为tom.github.io\n\n## 3.使用hexo写博客\n    - 新建一个文件夹myblog,\n    - 右键git bash here使用git的shell\n    - 在shell中输入hexo init,回车执行\n    - 在shell中输入hexo g ,回车\n    - 在shell中hexo s,回车\n    - 去浏览器访问http://localhost:4000,访问到主页,然后在shell中ctrl c停止\n    - 在shell中hexo new \"first-blog\",回车\n    - 在shell中hexo g ,回车\n    - 在shell中hexo s ,回车,在访问\n    - ok,在本地测试就没问题了\n\n## 4.发布到github\n打开项目根部录下的.config.yml,找到deploy,修改如下:\n\n```\n   deploy:\n    - type: git\n      repo: git@github.com:yourname/yourname.github.io.git,master\n```\n\n```\ndeploy:\n  type: git\n  repo: <repository url>\n  branch: [branch]\n  message: [message]\n```\n访问地址就是 http://tom.github.io/\n## 5.常用命令\n    命令的简写为：\n    ```\n    hexo n == hexo new\n    hexo g == hexo generate\n    hexo s == hexo server\n    hexo d == hexo deploy\n    hexo clean  删除public文件夹\n    ```\n\n## 6.常见问题\n1. 部署时出现git not found\n  - npm install hexo-deployer-git --save  安装依赖包\n\n\n## 7.详细设置    \n    每个人对自己的博客都有不一样的要求，比如主题，分类，标签，评论插件的选择，  \n    这些对程序员的你来说，都是小菜一碟，下面是官网教程：\n   [hexo官方文档][2]\n\n\n博客效果可以看我的个人博客     [我的个人博客][3]\n\n\n  [1]: https://hexo.io/zh-cn/\n  [2]: https://hexo.io/docs/\n  [3]: http://geeksblog.cc\n","tags":["hexo"],"categories":["开发工具"]},{"title":"Node学习","url":"/node-study.html","content":"** node学习： ** <Excerpt in index | 首页摘要>\n    nodejs学习的方法，进阶路线\n <!-- more -->\n<The rest of contents | 余下全文>\n\n## 一 学习内容\n1. node的常用模块,buffer,fs,http,net等.\n2. node常用框架express,mongoose,koa,mocha,should\n3. 部署上线,pm2,grunt,\n\n## 二 学习要点\n1. 了解node的特性和语法\n2. 编写扩展node模块\n3. 用异步的思想编程\n4. 常用框架的使用\n5. 回调的解决方案(promise)\n\n## 三 入门实战\n1. 参照nodejs实战上的微博系统,使用express4.x+ mongoose实现\n2. 使用socket.io实现一个简单的即时聊天的系统\n3. 使用mongoose+express+node开发一个论坛系统\n4. 使用koa+mongoose做一个简单的cms或者权限系统\n\n## 四 学习方法\n * 建议有基础的直接开始入门实战,在练习中熟悉node的api,做完一个项目再去看书\n * 不要一直看书,没什么效果的,实战永远是最有效的\n","tags":["node"],"categories":["编程语言"]}]